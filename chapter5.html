<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
  </style>
  <link rel="stylesheet" href="markdown.css" type="text/css" />
</head>
<body>
<h2 id="第五章-高级发布-订阅模式">第五章 高级发布-订阅模式</h2>
<p>第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。</p>
<p>本章涉及的内容有：</p>
<ul>
<li>处理慢订阅者（自杀的蜗牛模式）</li>
<li>高速订阅者（黑箱模式）</li>
<li>构建一个共享键值缓存（克隆模式）</li>
</ul>
<h3 id="检测慢订阅者自杀的蜗牛模式">检测慢订阅者（自杀的蜗牛模式）</h3>
<p>在使用发布-订阅模式的时候，最常见的问题之一是如何处理响应较慢的订阅者。理想状况下，发布者能以全速发送消息给订阅者，但现实中，订阅者会需要对消息做较长时间的处理，或者写得不够好，无法跟上发布者的脚步。</p>
<p>如何处理慢订阅者？最好的方法当然是让订阅者高效起来，不过这需要额外的工作。以下是一些处理慢订阅者的方法：</p>
<ul>
<li><p><strong>在发布者中贮存消息</strong>。这是Gmail的做法，如果过去的几小时里没有阅读邮件的话，它会把邮件保存起来。但在高吞吐量的应用中，发布者堆积消息往往会导致内存溢出，最终崩溃。特别是当同是有多个订阅者时，或者无法用磁盘来做一个缓冲，情况就会变得更为复杂。</p></li>
<li><p><strong>在订阅者中贮存消息</strong>。这种做法要好的多，其实ZMQ默认的行为就是这样的。如果非得有一个人会因为内存溢出而崩溃，那也只会是订阅者，而非发布者，这挺公平的。然而，这种做法只对瞬间消息量很大的应用才合理，订阅者只是一时处理不过来，但最终会赶上进度。但是，这还是没有解决订阅者速度过慢的问题。</p></li>
<li><p><strong>暂停发送消息</strong>。这也是Gmail的做法，当我的邮箱容量超过7.554GB时，新的邮件就会被Gmail拒收或丢弃。这种做法对发布者来说很有益，ZMQ中若设置了阈值（HWM），其默认行为也就是这样的。但是，我们仍不能解决慢订阅者的问题，我们只是让消息变得断断续续而已。</p></li>
<li><p><strong>断开与满订阅者的连接</strong>。这是hotmail的做法，如果连续两周没有登录，它就会断开，这也是为什么我正在使用第十五个hotmail邮箱。不过这种方案在ZMQ里是行不通的，因为对于发布者而言，订阅者是不可见的，无法做相应处理。</p></li>
</ul>
<p>看来没有一种经典的方式可以满足我们的需求，所以我们就要进行创新了。我们可以让订阅者自杀，而不仅仅是断开连接。这就是“自杀的蜗牛”模式。当订阅者发现自身运行得过慢时（对于慢速的定义应该是一个配置项，当达到这个标准时就大声地喊出来吧，让程序员知道），它会哀嚎一声，然后自杀。</p>
<p>订阅者如何检测自身速度过慢呢？一种方式是为消息进行编号，并在发布者端设置阈值。当订阅者发现消息编号不连续时，它就知道事情不对劲了。这里的阈值就是订阅者自杀的值。</p>
<p>这种方案有两个问题：一、如果我们连接的多个发布者，我们要如何为消息进行编号呢？解决方法是为每一个发布者设定一个唯一的编号，作为消息编号的一部分。二、如果订阅者使用ZMQ_SUBSRIBE选项对消息进行了过滤，那么我们精心设计的消息编号机制就毫无用处了。</p>
<p>有些情形不会进行消息的过滤，所以消息编号还是行得通的。不过更为普遍的解决方案是，发布者为消息标注时间戳，当订阅者收到消息时会检测这个时间戳，如果其差别达到某一个值，就发出警报并自杀。</p>
<p>当订阅者有自身的客户端或服务协议，需要保证最大延迟时间时，自杀的蜗牛模式会很合适。撤销一个订阅者也许并不是最周全的方案，但至少不会引发后续的问题。如果订阅者收到了过时的消息，那可能会对数据造成进一步的破坏，而且很难被发现。</p>
<p>以下是自杀的蜗牛模式的最简实现：</p>
<p><strong>suisnail: Suicidal Snail in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  自杀的蜗牛模式</span>
<span class="co">//</span>
<span class="ot">#include &quot;czmq.h&quot;</span>
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  该订阅者会连接至发布者，接收所有的消息，</span>
<span class="co">//  运行过程中它会暂停一会儿，模拟复杂的运算过程，</span>
<span class="co">//  当发现收到的消息超过1秒的延迟时，就自杀。</span>
 
<span class="ot">#define MAX_ALLOWED_DELAY   1000    </span><span class="co">//  毫秒</span>
 
<span class="dt">static</span> <span class="dt">void</span>
subscriber (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe)
{
    <span class="co">//  订阅所有消息</span>
    <span class="dt">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
 
    <span class="co">//  获取并处理消息</span>
    <span class="kw">while</span> (<span class="dv">1</span>) {
        <span class="dt">char</span> *string = zstr_recv (subscriber);
        <span class="dt">int64_t</span> clock;
        <span class="dt">int</span> terms = sscanf (string, <span class="st">&quot;%&quot;</span> PRId64, &amp;clock);
        assert (terms == <span class="dv">1</span>);
        free (string);
 
        <span class="co">//  自杀逻辑</span>
        <span class="kw">if</span> (zclock_time () - clock &gt; MAX_ALLOWED_DELAY) {
            fprintf (stderr, <span class="st">&quot;E: 订阅者无法跟进, 取消中</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">break</span>;
        }
        <span class="co">//  工作一定时间</span>
        zclock_sleep (<span class="dv">1</span> + randof (<span class="dv">2</span>));
    }
    zstr_send (pipe, <span class="st">&quot;订阅者中止&quot;</span>);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  发布者每毫秒发送一条用时间戳标记的消息</span>
 
<span class="dt">static</span> <span class="dt">void</span>
publisher (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe)
{
    <span class="co">//  准备发布者</span>
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, <span class="st">&quot;tcp://*:5556&quot;</span>);
 
    <span class="kw">while</span> (<span class="dv">1</span>) {
        <span class="co">//  发送当前时间（毫秒）给订阅者</span>
        <span class="dt">char</span> string [<span class="dv">20</span>];
        sprintf (string, <span class="st">&quot;%&quot;</span> PRId64, zclock_time ());
        zstr_send (publisher, string);
        <span class="dt">char</span> *signal = zstr_recv_nowait (pipe);
        <span class="kw">if</span> (signal) {
            free (signal);
            <span class="kw">break</span>;
        }
        zclock_sleep (<span class="dv">1</span>);            <span class="co">//  等待1毫秒</span>
    }
}
 
 
<span class="co">//  下面的代码会启动一个订阅者和一个发布者，当订阅者死亡时停止运行</span>
<span class="co">//</span>
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *pubpipe = zthread_fork (ctx, publisher, NULL);
    <span class="dt">void</span> *subpipe = zthread_fork (ctx, subscriber, NULL);
    free (zstr_recv (subpipe));
    zstr_send (pubpipe, <span class="st">&quot;break&quot;</span>);
    zclock_sleep (<span class="dv">100</span>);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>几点说明：</p>
<ul>
<li>示例程序中的消息包含了系统当前的时间戳（毫秒）。在现实应用中，你应该使用时间戳作为消息头，并提供消息内容。</li>
<li>示例程序中的发布者和订阅者是同一个进程的两个线程。在现实应用中，他们应该是两个不同的进程。示例中这么做只是为了演示的方便</li>
</ul>
<h3 id="高速订阅者黑箱模式">高速订阅者（黑箱模式）</h3>
<p>发布-订阅模式的一个典型应用场景是大规模分布式数据处理。如要处理从证券市场上收集到的数据，可以在证券交易系统上设置一个发布者，获取价格信息，并发送给一组订阅者。如果我们有很多订阅者，我们可以使用TCP。如果订阅者到达一定的量，那我们就应该使用可靠的广播协议，如pgm。</p>
<p>假设我们的发布者每秒产生10万条100个字节的消息。在剔除了不需要的市场信息后，这个比率还是比较合理的。现在我们需要记录一天的数据（8小时约有250GB），再将其传入一个模拟网络，即一组订阅者。虽然10万条数据对ZMQ来说很容易处理，但我们需要更高的速度。</p>
<p>假设我们有多台机器，一台做发布者，其他的做订阅者。这些机器都是8核的，发布者那台有12核。</p>
<p>在我们开始发布消息时，有两点需要注意：</p>
<ol style="list-style-type: decimal">
<li>即便只是处理很少的数据，订阅者仍有可能跟不上发布者的速度；</li>
<li>当处理到6M/s的数据量时，发布者和订阅者都有可能达到极限。</li>
</ol>
<p>首先，我们需要将订阅者设计为一种多线程的处理程序，这样我们就能在一个线程中读取消息，使用其他线程来处理消息。一般来说，我们对每种消息的处理方式都是不同的。这样一来，订阅者可以对收到的消息进行一次过滤，如根据头信息来判别。当消息满足某些条件，订阅者会将消息交给worker处理。用ZMQ的语言来说，订阅者会将消息转发给worker来处理。</p>
<p>这样一来，订阅者看上去就像是一个队列装置，我们可以用各种方式去连接队列装置和worker。如我们建立单向的通信，每个worker都是相同的，可以使用PUSH和PULL套接字，分发的工作就交给ZMQ吧。这是最简单也是最快速的方式：</p>
<div class="figure">
<img src="images/chapter5_1.png" alt="1" />
<p class="caption">1</p>
</div>
<p>订阅者和发布者之间的通信使用TCP或PGM协议，订阅者和worker的通信由于是在同一个进程中完成的，所以使用inproc协议。</p>
<p>下面我们看看如何突破瓶颈。由于订阅者是单线程的，当它的CPU占用率达到100%时，它无法使用其他的核心。单线程程序总是会遇到瓶颈的，不管是2M、6M还是更多。我们需要将工作量分配到不同的线程中去，并发地执行。</p>
<p>很多高性能产品使用的方案是分片，就是将工作量拆分成独立并行的流。如，一半的专题数据由一个流媒体传输，另一半由另一个流媒体传输。我们可以建立更多的流媒体，但如果CPU核心数不变，那就没有必要了。 让我们看看如何将工作量分片为两个流：</p>
<div class="figure">
<img src="images/chapter5_2.png" alt="2" />
<p class="caption">2</p>
</div>
<p>要让两个流全速工作，需要这样配置ZMQ：</p>
<ul>
<li>使用两个I/O线程，而不是一个；</li>
<li>使用两个独立的网络接口；</li>
<li>每个I/O线程绑定至一个网络接口；</li>
<li>两个订阅者线程，分别绑定至一个核心；</li>
<li>使用两个SUB套接字；</li>
<li>剩余的核心供worker使用；</li>
<li>worker线程同时绑定至两个订阅者线程的PUSH套接字。</li>
</ul>
<p>创建的线程数量应和CPU核心数一致，如果我们建立的线程数量超过核心数，那其处理速度只会减少。另外，开放多个I/O线程也是没有必要的。</p>
<h3 id="共享键值缓存克隆模式">共享键值缓存（克隆模式）</h3>
<p>发布-订阅模式和无线电广播有些类似，在你收听之前发送的消息你将无从得知，收到消息的多少又会取决于你的接收能力。让人吃惊的是，对于那些追求完美的工程师来说，这种机器恰恰符合他们的需求，且广为传播，成为现实生活中分发消息的最佳机制。想想非死不可、推特、BBS新闻、体育新闻等应用就知道了。</p>
<p>但是，在很多情形下，可靠的发布-订阅模式同样是有价值的。正如我们讨论请求-应答模式一样，我们会根据“故障”来定义“可靠性”，下面几项便是发布-订阅模式中可能发生的故障：</p>
<ul>
<li>订阅者连接太慢，因此没有收到发布者最初发送的消息；</li>
<li>订阅者速度太慢，同样会丢失消息；</li>
<li>订阅者可能会断开，其间的消息也会丢失。</li>
</ul>
<p>还有一些情况我们碰到的比较少，但不是没有：</p>
<ul>
<li>订阅者崩溃、重启，从而丢失了所有已收到的消息；</li>
<li>订阅者处理消息的速度过慢，导致消息在队列中堆砌并溢出；</li>
<li>因网络过载而丢失消息（特别是PGM协议下的连接）；</li>
<li>网速过慢，消息在发布者处溢出，从而崩溃。</li>
</ul>
<p>其实还会有其他出错的情况，只是以上这些在现实应用中是比较典型的。</p>
<p>我们已经有方法解决上面的某些问题了，比如对于慢速订阅者可以使用自杀的蜗牛模式。但是，对于其他的问题，我们最后能有一个可复用的框架来编写可靠的发布-订阅模式。</p>
<p>难点在于，我们并不知道目标应用程序会怎样处理这些数据。它们会进行过滤、只处理一部分消息吗？它们是否会将消息记录起来供日后使用？它们是否会将消息转发给其下的worker进行处理？需要考虑的情况实在太多了，每种情况都有其所谓的可靠性。</p>
<p>所以，我们将问题抽象出来，供多种应用程序使用。这种抽象应用我们称之为共享的键值缓存，它的功能是通过唯一的键名存储二进制数据块。</p>
<p>不要将这个抽象应用和分布式哈希表混淆起来，它是用来解决节点在分布式网络中相连接的问题的；也不要和分布式键值表混淆，它更像是一个NoSQL数据库。我们要建立的应用是将内存中的状态可靠地传递给一组客户端，它要做到的是：</p>
<ul>
<li>客户端可以随时加入网络，并获得服务端当前的状态；</li>
<li>任何客户端都可以改变键值缓存（插入、更新、删除）；</li>
<li>将这种变化以最短的延迟可靠地传达给所有的客户端；</li>
<li>能够处理大量的客户端，成百上千。</li>
</ul>
<p>克隆模式的要点在于客户端会反过来和服务端进行通信，这在简单的发布-订阅模式中并不常见。所以我这里使用“服务端”、“客户端”而不是“发布者”、“订阅者”这两个词。我们会使用发布-订阅模式作为核心消息模式，不过还需要夹杂其他模式。</p>
<h4 id="分发键值更新事件">分发键值更新事件</h4>
<p>我们会分阶段实施克隆模式。首先，我们看看如何从服务器发送键值更新事件给所有的客户端。我们将第一章中使用的天气服务模型进行改造，以键值对的方式发送信息，并让客户端使用哈希表来保存：</p>
<div class="figure">
<img src="images/chapter5_3.png" alt="3" />
<p class="caption">3</p>
</div>
<p>以下是服务端代码：</p>
<p><strong>clonesrv1: Clone server, Model One in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式服务端模型1</span>
<span class="co">//</span>
 
<span class="co">//  让我们直接编译，不生成类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和PUB套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, <span class="st">&quot;tcp://*:5556&quot;</span>);
    zclock_sleep (<span class="dv">200</span>);
 
    zhash_t *kvmap = zhash_new ();
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    srandom ((<span class="dt">unsigned</span>) time (NULL));
 
    <span class="kw">while</span> (!zctx_interrupted) {
        <span class="co">//  使用键值对分发消息</span>
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">10000</span>));
        kvmsg_fmt_body (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">1000000</span>));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_store   (&amp;kvmsg, kvmap);
    }
    printf (<span class="st">&quot; 已中止</span><span class="ch">\n</span><span class="st">已发送 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>以下是客户端代码：</p>
<p><strong>clonecli1: Clone client, Model One in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式客户端模型1</span>
<span class="co">//</span>
 
<span class="co">//  让我们直接编译，不生成类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和SUB套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *updates = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (updates, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
 
    zhash_t *kvmap = zhash_new ();
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
 
    <span class="kw">while</span> (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (updates);
        <span class="kw">if</span> (!kvmsg)
            <span class="kw">break</span>;          <span class="co">//  中断</span>
        kvmsg_store (&amp;kvmsg, kvmap);
        sequence++;
    }
    printf (<span class="st">&quot; 已中断</span><span class="ch">\n</span><span class="st">收到 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>几点说明：</p>
<ul>
<li>所有复杂的工作都在kvmsg类中完成了，这个类能够处理键值对类型的消息对象，其实质上是一个ZMQ多帧消息，共有三帧：键（ZMQ字符串）、编号（64位，按字节顺序排列）、二进制体（保存所有附加信息）。</li>
<li>服务端随机生成消息，使用四位数作为键，这样可以模拟大量而不是过量的哈希表（1万个条目）。</li>
<li>服务端绑定套接字后会等待200毫秒，以避免订阅者连接延迟而丢失数据的问题。我们会在后面的模型中解决这一点。</li>
<li>我们使用“发布者”和“订阅者”来命名程序中使用的套接字，这样可以避免和后续模型中的其他套接字发生混淆。</li>
</ul>
<p>以下是kvmsg的代码，已经经过了精简： <strong>kvsimple: Key-value message class in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  =====================================================================</span>
<span class="co">    kvsimple - simple key-value message class for example applications</span>
<span class="co"> </span>
<span class="co">    ---------------------------------------------------------------------</span>
<span class="co">    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;</span>
<span class="co">    Copyright other contributors as noted in the AUTHORS file.</span>
<span class="co"> </span>
<span class="co">    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org</span>
<span class="co"> </span>
<span class="co">    This is free software; you can redistribute it and/or modify it under</span>
<span class="co">    the terms of the GNU Lesser General Public License as published by</span>
<span class="co">    the Free Software Foundation; either version 3 of the License, or (at</span>
<span class="co">    your option) any later version.</span>
<span class="co"> </span>
<span class="co">    This software is distributed in the hope that it will be useful, but</span>
<span class="co">    WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="co">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="co">    Lesser General Public License for more details.</span>
<span class="co"> </span>
<span class="co">    You should have received a copy of the GNU Lesser General Public</span>
<span class="co">    License along with this program. If not, see</span>
<span class="co">    &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="co">    =====================================================================</span>
<span class="co">*/</span>
 
<span class="ot">#include &quot;kvsimple.h&quot;</span>
<span class="ot">#include &quot;zlist.h&quot;</span>
 
<span class="co">//  键是一个短字符串</span>
<span class="ot">#define KVMSG_KEY_MAX   255</span>
 
<span class="co">//  消息被格式化成三帧</span>
<span class="co">//  frame 0: 键（ZMQ字符串）</span>
<span class="co">//  frame 1: 编号（8个字节，按顺序排列）</span>
<span class="co">//  frame 2: 内容（二进制数据块）</span>
<span class="ot">#define FRAME_KEY       0</span>
<span class="ot">#define FRAME_SEQ       1</span>
<span class="ot">#define FRAME_BODY      2</span>
<span class="ot">#define KVMSG_FRAMES    3</span>
 
<span class="co">//  类结构</span>
<span class="kw">struct</span> _kvmsg {
    <span class="co">//  消息中某帧是否存在</span>
    <span class="dt">int</span> present [KVMSG_FRAMES];
    <span class="co">//  对应的ZMQ消息帧</span>
    zmq_msg_t frame [KVMSG_FRAMES];
    <span class="co">//  将键转换为C语言字符串</span>
    <span class="dt">char</span> key [KVMSG_KEY_MAX + <span class="dv">1</span>];
};
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  构造函数，设置编号</span>
 
kvmsg_t *
kvmsg_new (<span class="dt">int64_t</span> sequence)
{
    kvmsg_t
        *self;
 
    self = (kvmsg_t *) zmalloc (<span class="kw">sizeof</span> (kvmsg_t));
    kvmsg_set_sequence (self, sequence);
    <span class="kw">return</span> self;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  析构函数</span>
 
<span class="co">//  释放消息中的帧，可供zhash_freefn()函数调用</span>
<span class="dt">void</span>
kvmsg_free (<span class="dt">void</span> *ptr)
{
    <span class="kw">if</span> (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        <span class="co">//  销毁消息中的帧</span>
        <span class="dt">int</span> frame_nbr;
        <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            <span class="kw">if</span> (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
 
        <span class="co">//  释放对象本身</span>
        free (self);
    }
}
 
<span class="dt">void</span>
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  从套接字中读取键值消息，返回kvmsg实例</span>
 
kvmsg_t *
kvmsg_recv (<span class="dt">void</span> *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (<span class="dv">0</span>);
 
    <span class="co">//  读取所有帧，出错则销毁对象</span>
    <span class="dt">int</span> frame_nbr;
    <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        <span class="kw">if</span> (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = <span class="dv">1</span>;
        <span class="kw">if</span> (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], <span class="dv">0</span>) == -<span class="dv">1</span>) {
            kvmsg_destroy (&amp;self);
            <span class="kw">break</span>;
        }
        <span class="co">//  验证多帧消息</span>
        <span class="dt">int</span> rcvmore = (frame_nbr &lt; KVMSG_FRAMES - <span class="dv">1</span>)? <span class="dv">1</span>: <span class="dv">0</span>;
        <span class="kw">if</span> (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            <span class="kw">break</span>;
        }
    }
    <span class="kw">return</span> self;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  向套接字发送键值对消息，不检验消息帧的内容</span>
 
<span class="dt">void</span>
kvmsg_send (kvmsg_t *self, <span class="dt">void</span> *socket)
{
    assert (self);
    assert (socket);
 
    <span class="dt">int</span> frame_nbr;
    <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        <span class="kw">if</span> (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - <span class="dv">1</span>)? ZMQ_SNDMORE: <span class="dv">0</span>);
        zmq_msg_close (&amp;copy);
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  从消息中获取键值，不存在则返回NULL</span>
 
<span class="dt">char</span> *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_KEY]) {
        <span class="kw">if</span> (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            <span class="kw">if</span> (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = <span class="dv">0</span>;
        }
        <span class="kw">return</span> self-&gt;key;
    }
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息的编号</span>
 
<span class="dt">int64_t</span>
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == <span class="dv">8</span>);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        <span class="dt">int64_t</span> sequence = ((<span class="dt">int64_t</span>) (source [<span class="dv">0</span>]) &lt;&lt; <span class="dv">56</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">1</span>]) &lt;&lt; <span class="dv">48</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">2</span>]) &lt;&lt; <span class="dv">40</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">3</span>]) &lt;&lt; <span class="dv">32</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">4</span>]) &lt;&lt; <span class="dv">24</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">5</span>]) &lt;&lt; <span class="dv">16</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">6</span>]) &lt;&lt; <span class="dv">8</span>)
                         +  (<span class="dt">int64_t</span>) (source [<span class="dv">7</span>]);
        <span class="kw">return</span> sequence;
    }
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息内容，不存在则返回NULL</span>
 
byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        <span class="kw">return</span> (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息内容的大小</span>
 
size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        <span class="kw">return</span> zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息的键</span>
 
<span class="dt">void</span>
kvmsg_set_key (kvmsg_t *self, <span class="dt">char</span> *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    <span class="kw">if</span> (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息的编号</span>
 
<span class="dt">void</span>
kvmsg_set_sequence (kvmsg_t *self, <span class="dt">int64_t</span> sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    <span class="kw">if</span> (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, <span class="dv">8</span>);
 
    byte *source = zmq_msg_data (msg);
    source [<span class="dv">0</span>] = (byte) ((sequence &gt;&gt; <span class="dv">56</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">1</span>] = (byte) ((sequence &gt;&gt; <span class="dv">48</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">2</span>] = (byte) ((sequence &gt;&gt; <span class="dv">40</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">3</span>] = (byte) ((sequence &gt;&gt; <span class="dv">32</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">4</span>] = (byte) ((sequence &gt;&gt; <span class="dv">24</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">5</span>] = (byte) ((sequence &gt;&gt; <span class="dv">16</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">6</span>] = (byte) ((sequence &gt;&gt; <span class="dv">8</span>)  &amp; <span class="dv">255</span>);
    source [<span class="dv">7</span>] = (byte) ((sequence)       &amp; <span class="dv">255</span>);
 
    self-&gt;present [FRAME_SEQ] = <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息内容</span>
 
<span class="dt">void</span>
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = <span class="dv">1</span>;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  使用printf()格式设置消息键</span>
 
<span class="dt">void</span>
kvmsg_fmt_key (kvmsg_t *self, <span class="dt">char</span> *format, ...)
{
    <span class="dt">char</span> value [KVMSG_KEY_MAX + <span class="dv">1</span>];
    va_list args;
 
    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  使用springf()格式设置消息内容</span>
 
<span class="dt">void</span>
kvmsg_fmt_body (kvmsg_t *self, <span class="dt">char</span> *format, ...)
{
    <span class="dt">char</span> value [<span class="dv">255</span> + <span class="dv">1</span>];
    va_list args;
 
    assert (self);
    va_start (args, format);
    vsnprintf (value, <span class="dv">255</span>, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  若kvmsg结构的键值均存在，则存入哈希表；</span>
<span class="co">//  如果kvmsg结构已没有引用，则自动销毁和释放。</span>
 
<span class="dt">void</span>
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        <span class="kw">if</span> (self-&gt;present [FRAME_KEY]
        &amp;&amp;  self-&gt;present [FRAME_BODY]) {
            zhash_update (hash, kvmsg_key (self), self);
            zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
        }
        *self_p = NULL;
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  将消息内容打印至标准错误输出，用以调试和跟踪</span>
 
<span class="dt">void</span>
kvmsg_dump (kvmsg_t *self)
{
    <span class="kw">if</span> (self) {
        <span class="kw">if</span> (!self) {
            fprintf (stderr, <span class="st">&quot;NULL&quot;</span>);
            <span class="kw">return</span>;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, <span class="st">&quot;[seq:%&quot;</span> PRId64 <span class="st">&quot;]&quot;</span>, kvmsg_sequence (self));
        fprintf (stderr, <span class="st">&quot;[key:%s]&quot;</span>, kvmsg_key (self));
        fprintf (stderr, <span class="st">&quot;[size:%zd] &quot;</span>, size);
        <span class="dt">int</span> char_nbr;
        <span class="kw">for</span> (char_nbr = <span class="dv">0</span>; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, <span class="st">&quot;%02X&quot;</span>, body [char_nbr]);
        fprintf (stderr, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">else</span>
        fprintf (stderr, <span class="st">&quot;NULL message</span><span class="ch">\n</span><span class="st">&quot;</span>);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  测试用例</span>
 
<span class="dt">int</span>
kvmsg_test (<span class="dt">int</span> verbose)
{
    kvmsg_t
        *kvmsg;
 
    printf (<span class="st">&quot; * kvmsg: &quot;</span>);
 
    <span class="co">//  准备上下文和套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *output = zsocket_new (ctx, ZMQ_DEALER);
    <span class="dt">int</span> rc = zmq_bind (output, <span class="st">&quot;ipc://kvmsg_selftest.ipc&quot;</span>);
    assert (rc == <span class="dv">0</span>);
    <span class="dt">void</span> *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, <span class="st">&quot;ipc://kvmsg_selftest.ipc&quot;</span>);
    assert (rc == <span class="dv">0</span>);
 
    zhash_t *kvmap = zhash_new ();
 
    <span class="co">//  测试简单消息的发送和接受</span>
    kvmsg = kvmsg_new (<span class="dv">1</span>);
    kvmsg_set_key  (kvmsg, <span class="st">&quot;key&quot;</span>);
    kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;body&quot;</span>, <span class="dv">4</span>);
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);
 
    kvmsg = kvmsg_recv (input);
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), <span class="st">&quot;key&quot;</span>));
    kvmsg_store (&amp;kvmsg, kvmap);
 
    <span class="co">//  关闭并销毁所有对象</span>
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
 
    printf (<span class="st">&quot;OK</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>我们会在下文编写一个更为完整的kvmsg类，可以用到现实环境中。</p>
<p>客户端和服务端都会维护一个哈希表，但这个模型需要所有的客户端都比服务端启动得早，而且不能崩溃，这显然不能满足可靠性的要求。</p>
<h4 id="创建快照">创建快照</h4>
<p>为了让后续连接的（或从故障中恢复的）客户端能够获取服务器上的状态信息，需要让它在连接时获取一份快照。正如我们将“消息”的概念简化为“已编号的键值对”，我们也可以将“状态”简化为“一个哈希表”。为获取服务端状态，客户端会打开一个REQ套接字进行请求：</p>
<div class="figure">
<img src="images/chapter5_4.png" alt="4" />
<p class="caption">4</p>
</div>
<p>我们需要考虑时间的问题，因为生成快照是需要一定时间的，我们需要知道应从哪个更新事件开始更新快照，服务端是不知道何时有更新事件的。一种方法是先开始订阅消息，收到第一个消息之后向服务端请求“将该条更新之前的所有内容发送给”。这样一来，服务器需要为每一次更新保存一份快照，这显然是不现实的。</p>
<p>所以，我们会在客户端用以下方式进行同步：</p>
<ul>
<li><p>客户端开始订阅服务器的更新事件，然后请求一份快照。这样就能保证这份快照是在上一次更新事件之后产生的。</p></li>
<li><p>客户端开始等待服务器的快照，并将更新事件保存在队列中，做法很简单，不要从套接字中读取消息就可以了，ZMQ会自动将这些消息保存起来，这时不应设置阈值（HWM）。</p></li>
<li><p>当客户端获取到快照后，它将再次开始读取更新事件，但是需要丢弃那些早于快照生成时间的事件。如快照生成时包含了200次更新，那客户端会从第201次更新开始读取。</p></li>
<li><p>随后，客户端就会用更新事件去更新自身的状态了。</p></li>
</ul>
<p>这是一个比较简单的模型，因为它用到了ZMQ消息队列的机制。服务端代码如下：</p>
<p><strong>clonesrv2: Clone server, Model Two in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 - 服务端 - 模型2</span>
<span class="co">//</span>
 
<span class="co">//  让我们直接编译，不创建类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">void</span> state_manager (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe);
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备套接字和上下文</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, <span class="st">&quot;tcp://*:5557&quot;</span>);
 
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    srandom ((<span class="dt">unsigned</span>) time (NULL));
 
    <span class="co">//  开启状态管理器，并等待同步信号</span>
    <span class="dt">void</span> *updates = zthread_fork (ctx, state_manager, NULL);
    free (zstr_recv (updates));
 
    <span class="kw">while</span> (!zctx_interrupted) {
        <span class="co">//  分发键值消息</span>
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">10000</span>));
        kvmsg_fmt_body (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">1000000</span>));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_send     (kvmsg, updates);
        kvmsg_destroy (&amp;kvmsg);
    }
    printf (<span class="st">&quot; 已中断</span><span class="ch">\n</span><span class="st">已发送 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  快照请求方信息</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">void</span> *socket;           <span class="co">//  用于发送快照的ROUTER套接字</span>
    zframe_t *identity;     <span class="co">//  请求方的标识</span>
} kvroute_t;
 
<span class="co">//  发送快照中单个键值对</span>
<span class="co">//  使用kvmsg对象作为载体</span>
<span class="dt">static</span> <span class="dt">int</span>
s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    <span class="co">//  先发送接收方标识</span>
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  该线程维护服务端状态，并处理快照请求。</span>
<span class="co">//</span>
<span class="dt">static</span> <span class="dt">void</span>
state_manager (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe)
{
    zhash_t *kvmap = zhash_new ();
 
    zstr_send (pipe, <span class="st">&quot;READY&quot;</span>);
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, <span class="st">&quot;tcp://*:5556&quot;</span>);
 
    zmq_pollitem_t items [] = {
        { pipe, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> },
        { snapshot, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> }
    };
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;       <span class="co">//  当前快照版本</span>
    <span class="kw">while</span> (!zctx_interrupted) {
        <span class="dt">int</span> rc = zmq_poll (items, <span class="dv">2</span>, -<span class="dv">1</span>);
        <span class="kw">if</span> (rc == -<span class="dv">1</span> &amp;&amp; errno == ETERM)
            <span class="kw">break</span>;              <span class="co">//  上下文异常</span>
 
        <span class="co">//  等待主线程的更新事件</span>
        <span class="kw">if</span> (items [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (pipe);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        <span class="co">//  执行快照请求</span>
        <span class="kw">if</span> (items [<span class="dv">1</span>].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            <span class="kw">if</span> (!identity)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
 
            <span class="co">//  请求内容在第二帧中</span>
            <span class="dt">char</span> *request = zstr_recv (snapshot);
            <span class="kw">if</span> (streq (request, <span class="st">&quot;ICANHAZ?&quot;</span>))
                free (request);
            <span class="kw">else</span> {
                printf (<span class="st">&quot;E: 错误的请求，程序中止</span><span class="ch">\n</span><span class="st">&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="co">//  发送快照给客户端</span>
            kvroute_t routing = { snapshot, identity };
 
            <span class="co">//  逐项发送</span>
            zhash_foreach (kvmap, s_send_single, &amp;routing);
 
            <span class="co">//  发送结束标识，内含快照版本号</span>
            printf (<span class="st">&quot;正在发送快照，版本号 %d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, <span class="st">&quot;KTHXBAI&quot;</span>);
            kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;&quot;</span>, <span class="dv">0</span>);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    zhash_destroy (&amp;kvmap);
}</code></pre></div>
<p>以下是客户端代码：</p>
<p><strong>clonecli2: Clone client, Model Two in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// 克隆模式 - 客户端 - 模型2</span>
<span class="co">//</span>
 
<span class="co">//  让我们直接编译，不生成类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和SUB套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
    <span class="dt">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, <span class="st">&quot;tcp://localhost:5557&quot;</span>);
 
    zhash_t *kvmap = zhash_new ();
 
    <span class="co">//  获取快照</span>
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    zstr_send (snapshot, <span class="st">&quot;ICANHAZ?&quot;</span>);
    <span class="kw">while</span> (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        <span class="kw">if</span> (!kvmsg)
            <span class="kw">break</span>;          <span class="co">//  中断</span>
        <span class="kw">if</span> (streq (kvmsg_key (kvmsg), <span class="st">&quot;KTHXBAI&quot;</span>)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (<span class="st">&quot;已获取快照，版本号=%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            kvmsg_destroy (&amp;kvmsg);
            <span class="kw">break</span>;          <span class="co">//  完成</span>
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    <span class="co">//  应用队列中的更新事件，丢弃过时事件</span>
    <span class="kw">while</span> (!zctx_interrupted) {
        kvmsg_t *kvmsg = kvmsg_recv (subscriber);
        <span class="kw">if</span> (!kvmsg)
            <span class="kw">break</span>;          <span class="co">//  中断</span>
        <span class="kw">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) {
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        <span class="kw">else</span>
            kvmsg_destroy (&amp;kvmsg);
    }
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>几点说明：</p>
<ul>
<li><p>客户端使用两个线程，一个用来生成随机的更新事件，另一个用来管理状态。两者之间使用PAIR套接字通信。可能你会考虑使用SUB套接字，但是“慢连接”的问题会影响到程序运行。PAIR套接字会让两个线程严格同步的。</p></li>
<li><p>我们在updates套接字上设置了阈值（HWM），避免更新服务内存溢出。在inproc协议的连接中，阈值是两端套接字阈值的加和，所以要分别设置。</p></li>
<li><p>客户端比较简单，用C语言编写，大约60行代码。大多数工作都在kvmsg类中完成了，不过总的来说，克隆模式实现起来还是比较简单的。</p></li>
<li><p>我们没有用特别的方式来序列化状态内容。键值对用kvmsg对象表示，保存在一个哈希表中。在不同的时间请求状态时会得到不同的快照。</p></li>
<li><p>我们假设客户端只和一个服务进行通信，而且服务必须是正常运行的。我们暂不考虑如何从服务崩溃的情形中恢复过来。</p></li>
</ul>
<p>现在，这两段程序都还没有真正地工作起来，但已经能够正确地同步状态了。这是一个多种消息模式的混合体：进程内的PAIR、发布-订阅、ROUTER-DEALER等。</p>
<h4 id="重发键值更新事件">重发键值更新事件</h4>
<p>第二个模型中，键值更新事件都来自于服务器，构成了一个中心化的模型。但是我们需要的是一个能够在客户端进行更新的缓存，并能同步到其他客户端中。这时，服务端只是一个无状态的中间件，带来的好处有：</p>
<ul>
<li>我们不用太过关心服务端的可靠性，因为即使它崩溃了，我们仍能从客户端中获取完整的数据。</li>
<li>我们可以使用键值缓存在动态节点之间分享数据。</li>
</ul>
<p>客户端的键值更新事件会通过PUSH-PULL套接字传达给服务端：</p>
<div class="figure">
<img src="images/chapter5_5.png" alt="5" />
<p class="caption">5</p>
</div>
<p>我们为什么不让客户端直接将更新信息发送给其他客户端呢？虽然这样做可以减少延迟，但是就无法为更新事件添加自增的唯一编号了。很多应用程序都需要更新事件以某种方式排序，只有将消息发给服务端，由服务端分发更新消息，才能保证更新事件的顺序。</p>
<p>有了唯一的编号后，客户端还能检测到更多的故障：网络堵塞或队列溢出。如果客户端发现消息输入流有一段空白，它能采取措施。可能你会觉得此时让客户端通知服务端，让它重新发送丢失的信息，可以解决问题。但事实上没有必要这么做。消息流的空挡表示网络状况不好，如果再进行这样的请求，只会让事情变得更糟。所以一般的做法是由客户端发出警告，并停止运行，等到有专人来维护后再继续工作。 我们开始创建在客户端进行状态更新的模型。以下是客户端代码：</p>
<p><strong>clonesrv3: Clone server, Model Three in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 服务端 模型3</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不创建类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="co">//  快照请求方信息</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">void</span> *socket;           <span class="co">//  ROUTER套接字</span>
    zframe_t *identity;     <span class="co">//  请求方标识</span>
} kvroute_t;
 
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, <span class="st">&quot;tcp://*:5556&quot;</span>);
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, <span class="st">&quot;tcp://*:5557&quot;</span>);
    <span class="dt">void</span> *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, <span class="st">&quot;tcp://*:5558&quot;</span>);
 
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    zhash_t *kvmap = zhash_new ();
 
    zmq_pollitem_t items [] = {
        { collector, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> },
        { snapshot, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> }
    };
    <span class="kw">while</span> (!zctx_interrupted) {
        <span class="dt">int</span> rc = zmq_poll (items, <span class="dv">2</span>, <span class="dv">1000</span> * ZMQ_POLL_MSEC);
 
        <span class="co">//  执行来自客户端的更新事件</span>
        <span class="kw">if</span> (items [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (<span class="st">&quot;I: 发布更新事件 %5d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
        }
        <span class="co">//  响应快照请求</span>
        <span class="kw">if</span> (items [<span class="dv">1</span>].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            <span class="kw">if</span> (!identity)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
 
            <span class="co">//  请求内容在消息的第二帧中</span>
            <span class="dt">char</span> *request = zstr_recv (snapshot);
            <span class="kw">if</span> (streq (request, <span class="st">&quot;ICANHAZ?&quot;</span>))
                free (request);
            <span class="kw">else</span> {
                printf (<span class="st">&quot;E: 错误的请求，程序中止</span><span class="ch">\n</span><span class="st">&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="co">//  发送快照</span>
            kvroute_t routing = { snapshot, identity };
 
            <span class="co">//  逐条发送</span>
            zhash_foreach (kvmap, s_send_single, &amp;routing);
 
            <span class="co">//  发送结束标识和编号</span>
            printf (<span class="st">&quot;I: 正在发送快照，版本号：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, <span class="st">&quot;KTHXBAI&quot;</span>);
            kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;&quot;</span>, <span class="dv">0</span>);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    printf (<span class="st">&quot; 已中断</span><span class="ch">\n</span><span class="st">已处理 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对</span>
<span class="dt">static</span> <span class="dt">int</span>
s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    <span class="co">//  Send identity of recipient first</span>
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>以下是客户端代码：</p>
<p><strong>clonecli3: Clone client, Model Three in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 - 客户端 - 模型3</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不创建类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和SUB套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
    <span class="dt">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, <span class="st">&quot;tcp://localhost:5557&quot;</span>);
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, <span class="st">&quot;tcp://localhost:5558&quot;</span>);
 
    zhash_t *kvmap = zhash_new ();
    srandom ((<span class="dt">unsigned</span>) time (NULL));
 
    <span class="co">//  获取状态快照</span>
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    zstr_send (snapshot, <span class="st">&quot;ICANHAZ?&quot;</span>);
    <span class="kw">while</span> (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        <span class="kw">if</span> (!kvmsg)
            <span class="kw">break</span>;          <span class="co">//  中断</span>
        <span class="kw">if</span> (streq (kvmsg_key (kvmsg), <span class="st">&quot;KTHXBAI&quot;</span>)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (<span class="st">&quot;I: 已收到快照，版本号：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            kvmsg_destroy (&amp;kvmsg);
            <span class="kw">break</span>;          <span class="co">//  完成</span>
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    <span class="dt">int64_t</span> alarm = zclock_time () + <span class="dv">1000</span>;
    <span class="kw">while</span> (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> } };
        <span class="dt">int</span> tickless = (<span class="dt">int</span>) ((alarm - zclock_time ()));
        <span class="kw">if</span> (tickless &lt; <span class="dv">0</span>)
            tickless = <span class="dv">0</span>;
        <span class="dt">int</span> rc = zmq_poll (items, <span class="dv">1</span>, tickless * ZMQ_POLL_MSEC);
        <span class="kw">if</span> (rc == -<span class="dv">1</span>)
            <span class="kw">break</span>;              <span class="co">//  上下文被关闭</span>
 
        <span class="kw">if</span> (items [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
 
            <span class="co">//  丢弃过时消息，包括心跳</span>
            <span class="kw">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (<span class="st">&quot;I: 收到更新事件：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            }
            <span class="kw">else</span>
                kvmsg_destroy (&amp;kvmsg);
        }
        <span class="co">//  创建一个随机的更新事件</span>
        <span class="kw">if</span> (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (<span class="dv">0</span>);
            kvmsg_fmt_key  (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">10000</span>));
            kvmsg_fmt_body (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">1000000</span>));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + <span class="dv">1000</span>;
        }
    }
    printf (<span class="st">&quot; 已准备</span><span class="ch">\n</span><span class="st">收到 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>几点说明：</p>
<ul>
<li><p>服务端整合为一个线程，负责收集来自客户端的更新事件并转发给其他客户端。它使用PULL套接字获取更新事件，ROUTER套接字处理快照请求，以及PUB套接字发布更新事件。</p></li>
<li><p>客户端会每隔1秒左右发送随机的更新事件给服务端，现实中这一动作由应用程序触发。</p></li>
</ul>
<h4 id="子树克隆">子树克隆</h4>
<p>现实中的键值缓存会越变越多，而客户端可能只会需要部分缓存。我们可以使用子树的方式来实现：客户端在发送快照请求时告诉服务端它需要的子树，在订阅更新事件时也指明子树。</p>
<p>关于子树的语法有很多，一种是“分层路径”结构，另一种是“主题树”：</p>
<ul>
<li>分层路径：/some/list/of/paths</li>
<li>主题树：some.list.of.topics</li>
</ul>
<p>这里我们会使用分层路径结构，以此扩展服务端和客户端，进行子树操作。维护多个子树其实并不太困难，因此我们不在这里演示。</p>
<p>下面是服务端代码，由模型3衍化而来：</p>
<p><strong>clonesrv4: Clone server, Model Four in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 服务端 模型4</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不创建类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="co">//  快照请求方信息</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">void</span> *socket;           <span class="co">//  ROUTER套接字</span>
    zframe_t *identity;     <span class="co">//  请求方标识</span>
    <span class="dt">char</span> *subtree;          <span class="co">//  指定的子树</span>
} kvroute_t;
 
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, <span class="st">&quot;tcp://*:5556&quot;</span>);
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, <span class="st">&quot;tcp://*:5557&quot;</span>);
    <span class="dt">void</span> *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, <span class="st">&quot;tcp://*:5558&quot;</span>);
 
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    zhash_t *kvmap = zhash_new ();
 
    zmq_pollitem_t items [] = {
        { collector, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> },
        { snapshot, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> }
    };
    <span class="kw">while</span> (!zctx_interrupted) {
        <span class="dt">int</span> rc = zmq_poll (items, <span class="dv">2</span>, <span class="dv">1000</span> * ZMQ_POLL_MSEC);
 
        <span class="co">//  执行来自客户端的更新事件</span>
        <span class="kw">if</span> (items [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  Interrupted</span>
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (<span class="st">&quot;I: 发布更新事件 %5d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
        }
        <span class="co">//  响应快照请求</span>
        <span class="kw">if</span> (items [<span class="dv">1</span>].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            <span class="kw">if</span> (!identity)
                <span class="kw">break</span>;          <span class="co">//  Interrupted</span>
 
            <span class="co">//  请求内容在消息的第二帧中</span>
            <span class="dt">char</span> *request = zstr_recv (snapshot);
            <span class="dt">char</span> *subtree = NULL;
            <span class="kw">if</span> (streq (request, <span class="st">&quot;ICANHAZ?&quot;</span>)) {
                free (request);
                subtree = zstr_recv (snapshot);
            }
            <span class="kw">else</span> {
                printf (<span class="st">&quot;E: 错误的请求，程序中止</span><span class="ch">\n</span><span class="st">&quot;</span>);
                <span class="kw">break</span>;
            }
            <span class="co">//  发送快照</span>
            kvroute_t routing = { snapshot, identity, subtree };
 
            <span class="co">//  逐条发送</span>
            zhash_foreach (kvmap, s_send_single, &amp;routing);
 
            <span class="co">//  发送结束标识和编号</span>
            printf (<span class="st">&quot;I: 正在发送快照，版本号：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, <span class="st">&quot;KTHXBAI&quot;</span>);
            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="dv">0</span>);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    printf (<span class="st">&quot; 已中断</span><span class="ch">\n</span><span class="st">已处理 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对</span>
<span class="dt">static</span> <span class="dt">int</span>
s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    <span class="kw">if</span> (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == <span class="dv">0</span>) {
        <span class="co">//  先发送接收方的标识</span>
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>下面是客户端代码：</p>
<p><strong>clonecli4: Clone client, Model Four in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 - 客户端 - 模型4</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不创建类库</span>
<span class="ot">#include &quot;kvsimple.c&quot;</span>
 
<span class="ot">#define SUBTREE &quot;/client/&quot;</span>
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="co">//  准备上下文和SUB套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
    <span class="dt">void</span> *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, <span class="st">&quot;tcp://localhost:5557&quot;</span>);
    zsockopt_set_subscribe (subscriber, SUBTREE);
    <span class="dt">void</span> *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, <span class="st">&quot;tcp://localhost:5558&quot;</span>);
 
    zhash_t *kvmap = zhash_new ();
    srandom ((<span class="dt">unsigned</span>) time (NULL));
 
    <span class="co">//  获取状态快照</span>
    <span class="dt">int64_t</span> sequence = <span class="dv">0</span>;
    zstr_sendm (snapshot, <span class="st">&quot;ICANHAZ?&quot;</span>);
    zstr_send  (snapshot, SUBTREE);
    <span class="kw">while</span> (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        <span class="kw">if</span> (!kvmsg)
            <span class="kw">break</span>;          <span class="co">//  Interrupted</span>
        <span class="kw">if</span> (streq (kvmsg_key (kvmsg), <span class="st">&quot;KTHXBAI&quot;</span>)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (<span class="st">&quot;I: 已收到快照，版本号：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            kvmsg_destroy (&amp;kvmsg);
            <span class="kw">break</span>;          <span class="co">//  Done</span>
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
 
    <span class="dt">int64_t</span> alarm = zclock_time () + <span class="dv">1000</span>;
    <span class="kw">while</span> (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> } };
        <span class="dt">int</span> tickless = (<span class="dt">int</span>) ((alarm - zclock_time ()));
        <span class="kw">if</span> (tickless &lt; <span class="dv">0</span>)
            tickless = <span class="dv">0</span>;
        <span class="dt">int</span> rc = zmq_poll (items, <span class="dv">1</span>, tickless * ZMQ_POLL_MSEC);
        <span class="kw">if</span> (rc == -<span class="dv">1</span>)
            <span class="kw">break</span>;              <span class="co">//  上下文被关闭</span>
 
        <span class="kw">if</span> (items [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
 
            <span class="co">//  丢弃过时消息，包括心跳</span>
            <span class="kw">if</span> (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (<span class="st">&quot;I: 收到更新事件：%d</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
            }
            <span class="kw">else</span>
                kvmsg_destroy (&amp;kvmsg);
        }
        <span class="co">//  创建一个随机的更新事件</span>
        <span class="kw">if</span> (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (<span class="dv">0</span>);
            kvmsg_fmt_key  (kvmsg, <span class="st">&quot;%s%d&quot;</span>, SUBTREE, randof (<span class="dv">10000</span>));
            kvmsg_fmt_body (kvmsg, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">1000000</span>));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + <span class="dv">1000</span>;
        }
    }
    printf (<span class="st">&quot; 已准备</span><span class="ch">\n</span><span class="st">收到 %d 条消息</span><span class="ch">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h4 id="瞬间值">瞬间值</h4>
<p>瞬间值指的是那些会立刻过期的值。如果你用克隆模式搭建一个类似DNS的服务时，就可以用瞬间值来模拟动态DNS解析了。当节点连接网络，对外发布它的地址，并不断地更新地址。如果节点断开连接，则它的地址也会失效。</p>
<p>瞬间值可以和会话（session）联系起来，当会话结束时，瞬间值也就失效了。克隆模式中，会话是由客户端定义的，并会在客户端断开连接时消亡。</p>
<p>更简单的方法是为每一个瞬间值设定一个过期时间，客户端会不断延长这个时间，当断开连接时这个时间将得不到更新，服务器就会自动将其删除。</p>
<p>我们会用这种简单的方法来实现瞬间值，因为太过复杂的方法可能不值当，它们的差别仅在性能上体现。如果客户端有很多瞬间值，那为每个值设定过期时间是恰当的；如果瞬间值到达一定的量，那最好还是将其和会话相关联，统一进行过期处理。</p>
<p>首先，我们需要设法在键值对消息中加入过期时间。我们可以增加一个消息帧，但这样一来每当我们需要增加消息内容时就需要修改kvmsg类库了，这并不合适。所以，我们一次性增加一个“属性”消息帧，用于添加不同的消息属性。</p>
<p>其次，我们需要设法删除这条数据。目前为止服务端和客户端会盲目地增改哈希表中的数据，我们可以这样定义：当消息的值是空的，则表示删除这个键的数据。</p>
<p>下面是一个更为完整的kvmsg类代码，它实现了“属性”帧，以及一个UUID帧，我们后面会用到。该类还会负责处理值为空的消息，达到删除的目的：</p>
<p><strong>kvmsg: Key-value message class - full in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  =====================================================================</span>
<span class="co">    kvmsg - key-value message class for example applications</span>
<span class="co"> </span>
<span class="co">    ---------------------------------------------------------------------</span>
<span class="co">    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;</span>
<span class="co">    Copyright other contributors as noted in the AUTHORS file.</span>
<span class="co"> </span>
<span class="co">    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org</span>
<span class="co"> </span>
<span class="co">    This is free software; you can redistribute it and/or modify it under</span>
<span class="co">    the terms of the GNU Lesser General Public License as published by</span>
<span class="co">    the Free Software Foundation; either version 3 of the License, or (at</span>
<span class="co">    your option) any later version.</span>
<span class="co"> </span>
<span class="co">    This software is distributed in the hope that it will be useful, but</span>
<span class="co">    WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="co">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="co">    Lesser General Public License for more details.</span>
<span class="co"> </span>
<span class="co">    You should have received a copy of the GNU Lesser General Public</span>
<span class="co">    License along with this program. If not, see</span>
<span class="co">    &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="co">    =====================================================================</span>
<span class="co">*/</span>
 
<span class="ot">#include &quot;kvmsg.h&quot;</span>
<span class="ot">#include &lt;uuid/uuid.h&gt;</span>
<span class="ot">#include &quot;zlist.h&quot;</span>
 
<span class="co">//  键是短字符串</span>
<span class="ot">#define KVMSG_KEY_MAX   255</span>
 
<span class="co">//  消息包含五帧</span>
<span class="co">//  frame 0: 键(ZMQ字符串)</span>
<span class="co">//  frame 1: 编号(8个字节，按顺序排列)</span>
<span class="co">//  frame 2: UUID(二进制块，16个字节)</span>
<span class="co">//  frame 3: 属性(ZMQ字符串)</span>
<span class="co">//  frame 4: 值(二进制块)</span>
<span class="ot">#define FRAME_KEY       0</span>
<span class="ot">#define FRAME_SEQ       1</span>
<span class="ot">#define FRAME_UUID      2</span>
<span class="ot">#define FRAME_PROPS     3</span>
<span class="ot">#define FRAME_BODY      4</span>
<span class="ot">#define KVMSG_FRAMES    5</span>
 
<span class="co">//  类结构</span>
<span class="kw">struct</span> _kvmsg {
    <span class="co">//  帧是否存在</span>
    <span class="dt">int</span> present [KVMSG_FRAMES];
    <span class="co">//  对应消息帧</span>
    zmq_msg_t frame [KVMSG_FRAMES];
    <span class="co">//  键，C语言字符串格式</span>
    <span class="dt">char</span> key [KVMSG_KEY_MAX + <span class="dv">1</span>];
    <span class="co">//  属性列表，key=value形式</span>
    zlist_t *props;
    size_t props_size;
};
 
 
<span class="co">//  将属性列表序列化为字符串</span>
<span class="dt">static</span> <span class="dt">void</span>
s_encode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    <span class="kw">if</span> (self-&gt;present [FRAME_PROPS])
        zmq_msg_close (msg);
 
    zmq_msg_init_size (msg, self-&gt;props_size);
    <span class="dt">char</span> *prop = zlist_first (self-&gt;props);
    <span class="dt">char</span> *dest = (<span class="dt">char</span> *) zmq_msg_data (msg);
    <span class="kw">while</span> (prop) {
        strcpy (dest, prop);
        dest += strlen (prop);
        *dest++ = <span class="ch">&#39;\n&#39;</span>;
        prop = zlist_next (self-&gt;props);
    }
    self-&gt;present [FRAME_PROPS] = <span class="dv">1</span>;
}
 
<span class="co">//  从字符串中解析属性列表</span>
<span class="dt">static</span> <span class="dt">void</span>
s_decode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    self-&gt;props_size = <span class="dv">0</span>;
    <span class="kw">while</span> (zlist_size (self-&gt;props))
        free (zlist_pop (self-&gt;props));
 
    size_t remainder = zmq_msg_size (msg);
    <span class="dt">char</span> *prop = (<span class="dt">char</span> *) zmq_msg_data (msg);
    <span class="dt">char</span> *eoln = memchr (prop, <span class="ch">&#39;\n&#39;</span>, remainder);
    <span class="kw">while</span> (eoln) {
        *eoln = <span class="dv">0</span>;
        zlist_append (self-&gt;props, strdup (prop));
        self-&gt;props_size += strlen (prop) + <span class="dv">1</span>;
        remainder -= strlen (prop) + <span class="dv">1</span>;
        prop = eoln + <span class="dv">1</span>;
        eoln = memchr (prop, <span class="ch">&#39;\n&#39;</span>, remainder);
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  构造函数，指定消息编号</span>
 
kvmsg_t *
kvmsg_new (<span class="dt">int64_t</span> sequence)
{
    kvmsg_t
        *self;
 
    self = (kvmsg_t *) zmalloc (<span class="kw">sizeof</span> (kvmsg_t));
    self-&gt;props = zlist_new ();
    kvmsg_set_sequence (self, sequence);
    <span class="kw">return</span> self;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  析构函数</span>
 
<span class="co">//  释放内存函数，供zhash_free_fn()调用</span>
<span class="dt">void</span>
kvmsg_free (<span class="dt">void</span> *ptr)
{
    <span class="kw">if</span> (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        <span class="co">//  释放所有消息帧</span>
        <span class="dt">int</span> frame_nbr;
        <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            <span class="kw">if</span> (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
 
        <span class="co">//  释放属性列表</span>
        <span class="kw">while</span> (zlist_size (self-&gt;props))
            free (zlist_pop (self-&gt;props));
        zlist_destroy (&amp;self-&gt;props);
 
        <span class="co">//  释放对象本身</span>
        free (self);
    }
}
 
<span class="dt">void</span>
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  复制kvmsg对象</span>
 
kvmsg_t *
kvmsg_dup (kvmsg_t *self)
{
    kvmsg_t *kvmsg = kvmsg_new (<span class="dv">0</span>);
    <span class="dt">int</span> frame_nbr;
    <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        <span class="kw">if</span> (self-&gt;present [frame_nbr]) {
            zmq_msg_t *src = &amp;self-&gt;frame [frame_nbr];
            zmq_msg_t *dst = &amp;kvmsg-&gt;frame [frame_nbr];
            zmq_msg_init_size (dst, zmq_msg_size (src));
            memcpy (zmq_msg_data (dst),
                    zmq_msg_data (src), zmq_msg_size (src));
            kvmsg-&gt;present [frame_nbr] = <span class="dv">1</span>;
        }
    }
    kvmsg-&gt;props = zlist_copy (self-&gt;props);
    <span class="kw">return</span> kvmsg;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  从套接字总读取键值对，返回kvmsg实例</span>
 
kvmsg_t *
kvmsg_recv (<span class="dt">void</span> *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (<span class="dv">0</span>);
 
    <span class="co">//  读取所有帧，若有异常则直接返回空</span>
    <span class="dt">int</span> frame_nbr;
    <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        <span class="kw">if</span> (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = <span class="dv">1</span>;
        <span class="kw">if</span> (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], <span class="dv">0</span>) == -<span class="dv">1</span>) {
            kvmsg_destroy (&amp;self);
            <span class="kw">break</span>;
        }
        <span class="co">//  验证多帧消息</span>
        <span class="dt">int</span> rcvmore = (frame_nbr &lt; KVMSG_FRAMES - <span class="dv">1</span>)? <span class="dv">1</span>: <span class="dv">0</span>;
        <span class="kw">if</span> (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            <span class="kw">break</span>;
        }
    }
    <span class="kw">if</span> (self)
        s_decode_props (self);
    <span class="kw">return</span> self;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  向套接字发送键值对消息，空消息也发送</span>
 
<span class="dt">void</span>
kvmsg_send (kvmsg_t *self, <span class="dt">void</span> *socket)
{
    assert (self);
    assert (socket);
 
    s_encode_props (self);
    <span class="dt">int</span> frame_nbr;
    <span class="kw">for</span> (frame_nbr = <span class="dv">0</span>; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        <span class="kw">if</span> (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - <span class="dv">1</span>)? ZMQ_SNDMORE: <span class="dv">0</span>);
        zmq_msg_close (&amp;copy);
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息的键</span>
 
<span class="dt">char</span> *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_KEY]) {
        <span class="kw">if</span> (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            <span class="kw">if</span> (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = <span class="dv">0</span>;
        }
        <span class="kw">return</span> self-&gt;key;
    }
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息的编号</span>
 
<span class="dt">int64_t</span>
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == <span class="dv">8</span>);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        <span class="dt">int64_t</span> sequence = ((<span class="dt">int64_t</span>) (source [<span class="dv">0</span>]) &lt;&lt; <span class="dv">56</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">1</span>]) &lt;&lt; <span class="dv">48</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">2</span>]) &lt;&lt; <span class="dv">40</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">3</span>]) &lt;&lt; <span class="dv">32</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">4</span>]) &lt;&lt; <span class="dv">24</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">5</span>]) &lt;&lt; <span class="dv">16</span>)
                         + ((<span class="dt">int64_t</span>) (source [<span class="dv">6</span>]) &lt;&lt; <span class="dv">8</span>)
                         +  (<span class="dt">int64_t</span>) (source [<span class="dv">7</span>]);
        <span class="kw">return</span> sequence;
    }
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息的UUID</span>
 
byte *
kvmsg_uuid (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_UUID]
    &amp;&amp;  zmq_msg_size (&amp;self-&gt;frame [FRAME_UUID]) == <span class="kw">sizeof</span> (uuid_t))
        <span class="kw">return</span> (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_UUID]);
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息的内容</span>
 
byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        <span class="kw">return</span> (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  返回消息内容的长度</span>
 
size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        <span class="kw">return</span> zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息的键</span>
 
<span class="dt">void</span>
kvmsg_set_key (kvmsg_t *self, <span class="dt">char</span> *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    <span class="kw">if</span> (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息的编号</span>
 
<span class="dt">void</span>
kvmsg_set_sequence (kvmsg_t *self, <span class="dt">int64_t</span> sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    <span class="kw">if</span> (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, <span class="dv">8</span>);
 
    byte *source = zmq_msg_data (msg);
    source [<span class="dv">0</span>] = (byte) ((sequence &gt;&gt; <span class="dv">56</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">1</span>] = (byte) ((sequence &gt;&gt; <span class="dv">48</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">2</span>] = (byte) ((sequence &gt;&gt; <span class="dv">40</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">3</span>] = (byte) ((sequence &gt;&gt; <span class="dv">32</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">4</span>] = (byte) ((sequence &gt;&gt; <span class="dv">24</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">5</span>] = (byte) ((sequence &gt;&gt; <span class="dv">16</span>) &amp; <span class="dv">255</span>);
    source [<span class="dv">6</span>] = (byte) ((sequence &gt;&gt; <span class="dv">8</span>)  &amp; <span class="dv">255</span>);
    source [<span class="dv">7</span>] = (byte) ((sequence)       &amp; <span class="dv">255</span>);
 
    self-&gt;present [FRAME_SEQ] = <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  生成并设置消息的UUID</span>
 
<span class="dt">void</span>
kvmsg_set_uuid (kvmsg_t *self)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_UUID];
    uuid_t uuid;
    uuid_generate (uuid);
    <span class="kw">if</span> (self-&gt;present [FRAME_UUID])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, <span class="kw">sizeof</span> (uuid));
    memcpy (zmq_msg_data (msg), uuid, <span class="kw">sizeof</span> (uuid));
    self-&gt;present [FRAME_UUID] = <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息的内容</span>
 
<span class="dt">void</span>
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    <span class="kw">if</span> (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = <span class="dv">1</span>;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  使用printf()格式设置消息的键</span>
<span class="dt">void</span>
kvmsg_fmt_key (kvmsg_t *self, <span class="dt">char</span> *format, ...)
{
    <span class="dt">char</span> value [KVMSG_KEY_MAX + <span class="dv">1</span>];
    va_list args;
 
    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  使用printf()格式设置消息内容</span>
 
<span class="dt">void</span>
kvmsg_fmt_body (kvmsg_t *self, <span class="dt">char</span> *format, ...)
{
    <span class="dt">char</span> value [<span class="dv">255</span> + <span class="dv">1</span>];
    va_list args;
 
    assert (self);
    va_start (args, format);
    vsnprintf (value, <span class="dv">255</span>, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  获取消息属性，无则返回空字符串</span>
 
<span class="dt">char</span> *
kvmsg_get_prop (kvmsg_t *self, <span class="dt">char</span> *name)
{
    assert (strchr (name, &#39;=&#39;) == NULL);
    <span class="dt">char</span> *prop = zlist_first (self-&gt;props);
    size_t namelen = strlen (name);
    <span class="kw">while</span> (prop) {
        <span class="kw">if</span> (strlen (prop) &gt; namelen
        &amp;&amp;  memcmp (prop, name, namelen) == <span class="dv">0</span>
        &amp;&amp;  prop [namelen] == &#39;=&#39;)
            <span class="kw">return</span> prop + namelen + <span class="dv">1</span>;
        prop = zlist_next (self-&gt;props);
    }
    <span class="kw">return</span> <span class="st">&quot;&quot;</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置消息属性</span>
<span class="co">//  属性名称不能包含=号，值的最大长度是255</span>
 
<span class="dt">void</span>
kvmsg_set_prop (kvmsg_t *self, <span class="dt">char</span> *name, <span class="dt">char</span> *format, ...)
{
    assert (strchr (name, &#39;=&#39;) == NULL);
 
    <span class="dt">char</span> value [<span class="dv">255</span> + <span class="dv">1</span>];
    va_list args;
    assert (self);
    va_start (args, format);
    vsnprintf (value, <span class="dv">255</span>, format, args);
    va_end (args);
 
    <span class="co">//  分配空间</span>
    <span class="dt">char</span> *prop = malloc (strlen (name) + strlen (value) + <span class="dv">2</span>);
 
    <span class="co">//  删除已存在的属性</span>
    sprintf (prop, <span class="st">&quot;%s=&quot;</span>, name);
    <span class="dt">char</span> *existing = zlist_first (self-&gt;props);
    <span class="kw">while</span> (existing) {
        <span class="kw">if</span> (memcmp (prop, existing, strlen (prop)) == <span class="dv">0</span>) {
            self-&gt;props_size -= strlen (existing) + <span class="dv">1</span>;
            zlist_remove (self-&gt;props, existing);
            free (existing);
            <span class="kw">break</span>;
        }
        existing = zlist_next (self-&gt;props);
    }
    <span class="co">//  添加新属性</span>
    strcat (prop, value);
    zlist_append (self-&gt;props, prop);
    self-&gt;props_size += strlen (prop) + <span class="dv">1</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  在哈希表中保存kvmsg对象</span>
<span class="co">//  当kvmsg对象不再被使用时进行释放操作；</span>
<span class="co">//  若传入的值为空，则删除该对象。</span>
 
<span class="dt">void</span>
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        <span class="kw">if</span> (kvmsg_size (self)) {
            <span class="kw">if</span> (self-&gt;present [FRAME_KEY]
            &amp;&amp;  self-&gt;present [FRAME_BODY]) {
                zhash_update (hash, kvmsg_key (self), self);
                zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
            }
        }
        <span class="kw">else</span>
            zhash_delete (hash, kvmsg_key (self));
 
        *self_p = NULL;
    }
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  将消息内容输出到标准错误输出</span>
 
<span class="dt">void</span>
kvmsg_dump (kvmsg_t *self)
{
    <span class="kw">if</span> (self) {
        <span class="kw">if</span> (!self) {
            fprintf (stderr, <span class="st">&quot;NULL&quot;</span>);
            <span class="kw">return</span>;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, <span class="st">&quot;[seq:%&quot;</span> PRId64 <span class="st">&quot;]&quot;</span>, kvmsg_sequence (self));
        fprintf (stderr, <span class="st">&quot;[key:%s]&quot;</span>, kvmsg_key (self));
        fprintf (stderr, <span class="st">&quot;[size:%zd] &quot;</span>, size);
        <span class="kw">if</span> (zlist_size (self-&gt;props)) {
            fprintf (stderr, <span class="st">&quot;[&quot;</span>);
            <span class="dt">char</span> *prop = zlist_first (self-&gt;props);
            <span class="kw">while</span> (prop) {
                fprintf (stderr, <span class="st">&quot;%s;&quot;</span>, prop);
                prop = zlist_next (self-&gt;props);
            }
            fprintf (stderr, <span class="st">&quot;]&quot;</span>);
        }
        <span class="dt">int</span> char_nbr;
        <span class="kw">for</span> (char_nbr = <span class="dv">0</span>; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, <span class="st">&quot;%02X&quot;</span>, body [char_nbr]);
        fprintf (stderr, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">else</span>
        fprintf (stderr, <span class="st">&quot;NULL message</span><span class="ch">\n</span><span class="st">&quot;</span>);
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  测试用例</span>
 
<span class="dt">int</span>
kvmsg_test (<span class="dt">int</span> verbose)
{
    kvmsg_t
        *kvmsg;
 
    printf (<span class="st">&quot; * kvmsg: &quot;</span>);
 
    <span class="co">//  准备上下文和套接字</span>
    zctx_t *ctx = zctx_new ();
    <span class="dt">void</span> *output = zsocket_new (ctx, ZMQ_DEALER);
    <span class="dt">int</span> rc = zmq_bind (output, <span class="st">&quot;ipc://kvmsg_selftest.ipc&quot;</span>);
    assert (rc == <span class="dv">0</span>);
    <span class="dt">void</span> *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, <span class="st">&quot;ipc://kvmsg_selftest.ipc&quot;</span>);
    assert (rc == <span class="dv">0</span>);
 
    zhash_t *kvmap = zhash_new ();
 
    <span class="co">//  测试简单消息的收发</span>
    kvmsg = kvmsg_new (<span class="dv">1</span>);
    kvmsg_set_key  (kvmsg, <span class="st">&quot;key&quot;</span>);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;body&quot;</span>, <span class="dv">4</span>);
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);
 
    kvmsg = kvmsg_recv (input);
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), <span class="st">&quot;key&quot;</span>));
    kvmsg_store (&amp;kvmsg, kvmap);
 
    <span class="co">// 测试带有属性的消息的收发</span>
    kvmsg = kvmsg_new (<span class="dv">2</span>);
    kvmsg_set_prop (kvmsg, <span class="st">&quot;prop1&quot;</span>, <span class="st">&quot;value1&quot;</span>);
    kvmsg_set_prop (kvmsg, <span class="st">&quot;prop2&quot;</span>, <span class="st">&quot;value1&quot;</span>);
    kvmsg_set_prop (kvmsg, <span class="st">&quot;prop2&quot;</span>, <span class="st">&quot;value2&quot;</span>);
    kvmsg_set_key  (kvmsg, <span class="st">&quot;key&quot;</span>);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;body&quot;</span>, <span class="dv">4</span>);
    assert (streq (kvmsg_get_prop (kvmsg, <span class="st">&quot;prop2&quot;</span>), <span class="st">&quot;value2&quot;</span>));
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_destroy (&amp;kvmsg);
 
    kvmsg = kvmsg_recv (input);
    <span class="kw">if</span> (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), <span class="st">&quot;key&quot;</span>));
    assert (streq (kvmsg_get_prop (kvmsg, <span class="st">&quot;prop2&quot;</span>), <span class="st">&quot;value2&quot;</span>));
    kvmsg_destroy (&amp;kvmsg);
 
    <span class="co">//  关闭并销毁所有对象</span>
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
 
    printf (<span class="st">&quot;OK</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>客户端模型5和模型4没有太大区别，只是kvmsg类库变了。在更新消息的时候还需要添加一个过期时间的属性：</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">kvmsg_set_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>, <span class="st">&quot;%d&quot;</span>, randof (<span class="dv">30</span>));</code></pre></div>
<p>服务端模型5有较大的变化，我们会用反应堆来代替轮询，这样就能混合处理定时事件和套接字事件了，只是在C语言中是比较麻烦的。下面是代码：</p>
<p><strong>clonesrv5: Clone server, Model Five in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">//  克隆模式 - 服务端 - 模型5</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不建类库</span>
<span class="ot">#include &quot;kvmsg.c&quot;</span>
 
<span class="co">//  反应堆处理器</span>
<span class="dt">static</span> <span class="dt">int</span> s_snapshots  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_collector  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_flush_ttl  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
 
<span class="co">//  服务器属性</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    zctx_t *ctx;                <span class="co">//  上下文</span>
    zhash_t *kvmap;             <span class="co">//  键值对存储</span>
    zloop_t *loop;              <span class="co">//  zloop反应堆</span>
    <span class="dt">int</span> port;                   <span class="co">//  主端口</span>
    <span class="dt">int64_t</span> sequence;           <span class="co">//  更新事件编号</span>
    <span class="dt">void</span> *snapshot;             <span class="co">//  处理快照请求</span>
    <span class="dt">void</span> *publisher;            <span class="co">//  发布更新事件</span>
    <span class="dt">void</span> *collector;            <span class="co">//  从客户端收集接收更新事件</span>
} clonesrv_t;
 
 
<span class="dt">int</span> main (<span class="dt">void</span>)
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (<span class="kw">sizeof</span> (clonesrv_t));
 
    self-&gt;port = <span class="dv">5556</span>;
    self-&gt;ctx = zctx_new ();
    self-&gt;kvmap = zhash_new ();
    self-&gt;loop = zloop_new ();
    zloop_set_verbose (self-&gt;loop, FALSE);
 
    <span class="co">//  打开克隆模式服务端套接字</span>
    self-&gt;snapshot  = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_PULL);
    zsocket_bind (self-&gt;snapshot,  <span class="st">&quot;tcp://*:%d&quot;</span>, self-&gt;port);
    zsocket_bind (self-&gt;publisher, <span class="st">&quot;tcp://*:%d&quot;</span>, self-&gt;port + <span class="dv">1</span>);
    zsocket_bind (self-&gt;collector, <span class="st">&quot;tcp://*:%d&quot;</span>, self-&gt;port + <span class="dv">2</span>);
 
    <span class="co">//  注册反应堆处理程序</span>
    zloop_reader (self-&gt;loop, self-&gt;snapshot, s_snapshots, self);
    zloop_reader (self-&gt;loop, self-&gt;collector, s_collector, self);
    zloop_timer  (self-&gt;loop, <span class="dv">1000</span>, <span class="dv">0</span>, s_flush_ttl, self);
 
    <span class="co">//  运行反应堆，直至中断</span>
    zloop_start (self-&gt;loop);
 
    zloop_destroy (&amp;self-&gt;loop);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  发送快照内容</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="co">//  请求方信息</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">void</span> *socket;           <span class="co">//  ROUTER套接字</span>
    zframe_t *identity;     <span class="co">//  请求方标识</span>
    <span class="dt">char</span> *subtree;          <span class="co">//  子树信息</span>
} kvroute_t;
 
<span class="dt">static</span> <span class="dt">int</span>
s_snapshots (zloop_t *loop, <span class="dt">void</span> *snapshot, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    zframe_t *identity = zframe_recv (snapshot);
    <span class="kw">if</span> (identity) {
        <span class="co">//  请求位于消息第二帧</span>
        <span class="dt">char</span> *request = zstr_recv (snapshot);
        <span class="dt">char</span> *subtree = NULL;
        <span class="kw">if</span> (streq (request, <span class="st">&quot;ICANHAZ?&quot;</span>)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        <span class="kw">else</span>
            printf (<span class="st">&quot;E: 错误的请求，程序中止</span><span class="ch">\n</span><span class="st">&quot;</span>);
 
        <span class="kw">if</span> (subtree) {
            <span class="co">//  发送状态快照</span>
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);
 
            <span class="co">//  发送结束符和版本号</span>
            zclock_log (<span class="st">&quot;I: 正在发送快照，版本号：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, <span class="st">&quot;KTHXBAI&quot;</span>);
            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="dv">0</span>);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  每次发送一个快照键值对</span>
<span class="dt">static</span> <span class="dt">int</span>
s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    <span class="kw">if</span> (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == <span class="dv">0</span>) {
        <span class="co">//  先发送接收方标识</span>
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  收集更新事件</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_collector (zloop_t *loop, <span class="dt">void</span> *collector, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    kvmsg_t *kvmsg = kvmsg_recv (collector);
    <span class="kw">if</span> (kvmsg) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        <span class="dt">int</span> ttl = atoi (kvmsg_get_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>));
        <span class="kw">if</span> (ttl)
            kvmsg_set_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>,
                <span class="st">&quot;%&quot;</span> PRId64, zclock_time () + ttl * <span class="dv">1000</span>);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (<span class="st">&quot;I: 正在发布更新事件 %d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  删除过期的瞬间值</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_flush_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="dt">static</span> <span class="dt">int</span>
s_flush_ttl (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  删除过期的键值对，并广播该事件</span>
<span class="dt">static</span> <span class="dt">int</span>
s_flush_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    <span class="dt">int64_t</span> ttl;
    sscanf (kvmsg_get_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>), <span class="st">&quot;%&quot;</span> PRId64, &amp;ttl);
    <span class="kw">if</span> (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;&quot;</span>, <span class="dv">0</span>);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (<span class="st">&quot;I: 发布删除事件 %d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h4 id="克隆服务器的可靠性">克隆服务器的可靠性</h4>
<p>克隆模型1至5相对比较简单，下面我们会探讨一个非常复杂的模型。可以发现，为了构建可靠的消息队列，我们需要花费非常多的精力。所以我们经常会问：有必要这么做吗？如果说你能够接受可靠性不够高的、或者说已经足够好的架构，那恭喜你，你在成本和收益之间找到了平衡。虽然我们会偶尔丢失一些消息，但从经济的角度来说还是合理的。不管怎样，下面我们就来介绍这个复杂的模型。</p>
<p>在模型3中，你会关闭和重启服务，这会导致数据的丢失。任何后续加入的客户端只能得到重启之后的那些数据，而非所有的。下面就让我们想办法让克隆模式能够承担服务器重启的故障。</p>
<p>以下列举我们需要处理的问题：</p>
<ul>
<li><p>克隆服务器进程崩溃并自动或手工重启。进程丢失了所有数据，所以必须从别处进行恢复。</p></li>
<li><p>克隆服务器硬件故障，长时间不能恢复。客户端需要切换至另一个可用的服务端。</p></li>
<li><p>克隆服务器从网络上断开，如交换机发生故障等。它会在某个时点重连，但期间的数据就需要替代的服务器负责处理。</p></li>
</ul>
<p>第一步我们需要增加一个服务器。我们可以使用第四章中提到的双子星模式，它是一个反应堆，而我们的程序经过整理后也是一个反应堆，因此可以互相协作。</p>
<p>我们需要保证更新事件在主服务器崩溃时仍能保留，最简单的机制就是同时发送给两台服务器。</p>
<p>备机就可以当做一台客户端来运行，像其他客户端一样从主机获取更新事件。同时它又能从客户端获取更新事件——虽然不应该以此更新数据，但可以先暂存起来。</p>
<p>所以，相较于模型5，模型6中引入了以下特性：</p>
<ul>
<li><p>客户端发送更新事件改用PUB-SUB套接字，而非PUSH-PULL。原因是PUSH套接字会在没有接收方时阻塞，且会进行负载均衡——我们需要两台服务器都接收到消息。我们会在服务器端绑定SUB套接字，在客户端连接PUB套接字。</p></li>
<li><p>我们在服务器发送给客户端的更新事件中加入心跳，这样客户端可以知道主机是否已死，然后切换至备机。</p></li>
<li><p>我们使用双子星模式的bstar反应堆类来创建主机和备机。双子星模式中需要有一个“投票”套接字，来协助判定对方节点是否已死。这里我们使用快照请求来作为“投票”。</p></li>
<li><p>我们将为所有的更新事件添加UUID属性，它由客户端生成，服务端会将其发布给所有客户端。</p></li>
<li><p>备机将维护一个“待处理列表”，保存来自客户端、尚未由服务端发布的更新事件；或者反过来，来自服务端、尚未从客户端收到的更新事件。这个列表从旧到新排列，这样就能方便地从顶部删除消息。</p></li>
</ul>
<p>我们可以为客户端设计一个有限状态机，它有三种状态：</p>
<ul>
<li><p>客户端打开并连接了套接字，然后向服务端发送快照请求。为了避免消息风暴，它只会请求两次。</p></li>
<li><p>客户端等待快照应答，如果获得了则保存它；如果没有获得，则向第二个服务器发送请求。</p></li>
<li><p>客户端收到快照，便开始等待更新事件。如果在一定时间内没有收到服务端响应，则会连接第二个服务端。</p></li>
</ul>
<p>客户端会一直循环下去，可能在程序刚启动时，部分客户端会试图连接主机，部分连接备机，相信双子星模式会很好地处理这一情况的。</p>
<p>我们可以将客户端状态图绘制出来：</p>
<div class="figure">
<img src="images/chapter5_6.png" alt="6" />
<p class="caption">6</p>
</div>
<p>故障恢复的步骤如下： * 客户端检测到主机不再发送心跳，因此转而连接备机，并请求一份新的快照； * 备机开始接收快照请求，并检测到主机死亡，于是开始作为主机运行； * 备机将待处理列表中的更新事件写入自身状态中，然后开始处理快照请求。</p>
<p>当主机恢复连接时： * 启动为slave状态，并作为克隆模式客户端连接备机； * 同时，使用SUB套接字从客户端接收更新事件。</p>
<p>我们做两点假设： * 至少有一台主机会继续运行。如果两台主机都崩溃了，那我们将丢失所有的服务端数据，无法恢复。 * 不同的客户端不会同时更新同一个键值对。客户端的更新事件会先后到达两个服务器，因此更新的顺序可能会不一致。单个客户端的更新事件到达两台服务器的顺序是相同的，所以不用担心。</p>
<p>下面是整体架构图：</p>
<div class="figure">
<img src="images/chapter5_7.png" alt="7" />
<p class="caption">7</p>
</div>
<p>开始编程之前，我们需要将客户端重构成一个可复用的类。在ZMQ中写异步类有时是为了练习如何写出优雅的代码，但这里我们确实是希望克隆模式可以成为一种易于使用的程序。上述架构的伸缩性来源于客户端的正确行为，因此有必要将其封装成一份API。要在客户端中进行故障恢复还是比较复杂的，试想一下自由者模式和克隆模式结合起来会是什么样的吧。</p>
<p>按照我的习惯，我会先写出一份API的列表，然后加以实现。让我们假想一个名为clone的API，在其基础之上编写克隆模式客户端API。将代码封装为API显然会提升代码的稳定性，就以模型5为例，客户端需要打开三个套接字，端点名称直接写在了代码里。我们可以创建这样一组API：</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="co">//  为每个套接字指定端点</span>
    clone_subscribe (clone, <span class="st">&quot;tcp://localhost:5556&quot;</span>);
    clone_snapshot  (clone, <span class="st">&quot;tcp://localhost:5557&quot;</span>);
    clone_updates   (clone, <span class="st">&quot;tcp://localhost:5558&quot;</span>);

    <span class="co">//  由于有两个服务端，因此再执行一次</span>
    clone_subscribe (clone, <span class="st">&quot;tcp://localhost:5566&quot;</span>);
    clone_snapshot  (clone, <span class="st">&quot;tcp://localhost:5567&quot;</span>);
    clone_updates   (clone, <span class="st">&quot;tcp://localhost:5568&quot;</span>);</code></pre></div>
<p>但这种写法还是比较啰嗦的，因为没有必要将API内部的一些设计暴露给编程人员。现在我们会使用三个套接字，而将来可能就会使用两个，或者四个。我们不可能让所有的应用程序都相应地修改吧？让我们把这些信息包装到API中：</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="co">//  指定主备服务器端点</span>
    clone_connect (clone, <span class="st">&quot;tcp://localhost:5551&quot;</span>);
    clone_connect (clone, <span class="st">&quot;tcp://localhost:5561&quot;</span>);</code></pre></div>
<p>这样一来代码就变得非常简洁，不过也会对现有代码的内部就够造成影响。我们需要从一个端点中推算出三个端点。一种方法是假设客户端和服务端使用三个连续的端点通信，并将这个规则写入协议；另一个方法是向服务器索取缺少的端点信息。我们使用第一种较为简单的方法：</p>
<ul>
<li>服务器状态ROUTER在端点P；</li>
<li>服务器更新事件PUB在端点P + 1；</li>
<li>服务器更新事件SUB在端点P + 2。</li>
</ul>
<p>clone类和第四章的flcliapi类很类似，由两部分组成：</p>
<ul>
<li>一个在后台运行的异步克隆模式代理。该代理处理所有的I/O操作，实时地和服务器进行通信；</li>
<li>一个在前台应用程序中同步运行的clone类。当你创建了一个clone对象后，它会自动创建后台的clone线程；当你销毁clone对象，该后台线程也会被销毁。</li>
</ul>
<p>前台的clone类会使用inproc管道和后台的代理进行通信。C语言中，czmq线程会自动为我们创建这个管道。这也是ZMQ多线程编程的常规方式。</p>
<p>如果没有ZMQ，这种异步的设计将很难处理高压工作，而ZMQ会让其变得简单。编写出来额代码会相对比较复杂。我们可以用反应堆的模式来编写，但这会进一步增加复杂度，且影响应用程序的使用。因此，我们的设计的API将更像是一个能够和服务器进行通信的键值表：</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">clone_t *clone_new (<span class="dt">void</span>);
<span class="dt">void</span> clone_destroy (clone_t **self_p);
<span class="dt">void</span> clone_connect (clone_t *self, <span class="dt">char</span> *address, <span class="dt">char</span> *service);
<span class="dt">void</span> clone_set (clone_t *self, <span class="dt">char</span> *key, <span class="dt">char</span> *value);
<span class="dt">char</span> *clone_get (clone_t *self, <span class="dt">char</span> *key);</code></pre></div>
<p>下面就是克隆模式客户端模型6的代码，因为调用了API，所以非常简短： <strong>clonecli6: Clone client, Model Six in C</strong></p>
<pre><code>//
//  克隆模式 - 客户端 - 模型6
//
 
//  直接编译，不建类库
#include &quot;clone.c&quot;
 
#define SUBTREE &quot;/client/&quot;
 
int main (void)
{
    //  创建分布式哈希表
    clone_t *clone = clone_new ();
 
    //  配置
    clone_subtree (clone, SUBTREE);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5556&quot;);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5566&quot;);
 
    //  插入随机键值
    while (!zctx_interrupted) {
        //  生成随机值
        char key [255];
        char value [10];
        sprintf (key, &quot;%s%d&quot;, SUBTREE, randof (10000));
        sprintf (value, &quot;%d&quot;, randof (1000000));
        clone_set (clone, key, value, randof (30));
        sleep (1);
    }
    clone_destroy (&amp;clone);
    return 0;
}</code></pre>
<p>以下是clone类的实现： <strong>clone: Clone class in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  =====================================================================</span>
<span class="co">    clone - client-side Clone Pattern class</span>
<span class="co"> </span>
<span class="co">    ---------------------------------------------------------------------</span>
<span class="co">    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;</span>
<span class="co">    Copyright other contributors as noted in the AUTHORS file.</span>
<span class="co"> </span>
<span class="co">    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org</span>
<span class="co"> </span>
<span class="co">    This is free software; you can redistribute it and/or modify it under</span>
<span class="co">    the terms of the GNU Lesser General Public License as published by</span>
<span class="co">    the Free Software Foundation; either version 3 of the License, or (at</span>
<span class="co">    your option) any later version.</span>
<span class="co"> </span>
<span class="co">    This software is distributed in the hope that it will be useful, but</span>
<span class="co">    WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="co">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="co">    Lesser General Public License for more details.</span>
<span class="co"> </span>
<span class="co">    You should have received a copy of the GNU Lesser General Public</span>
<span class="co">    License along with this program. If not, see</span>
<span class="co">    &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="co">    =====================================================================</span>
<span class="co">*/</span>
 
<span class="ot">#include &quot;clone.h&quot;</span>
 
<span class="co">//  请求超时时间</span>
<span class="ot">#define GLOBAL_TIMEOUT  4000    </span><span class="co">//  msecs</span>
<span class="co">//  判定服务器死亡的时间</span>
<span class="ot">#define SERVER_TTL      5000    </span><span class="co">//  msecs</span>
<span class="co">//  服务器数量</span>
<span class="ot">#define SERVER_MAX      2</span>
 
 
<span class="co">//  =====================================================================</span>
<span class="co">//  同步部分，在应用程序线程中工作</span>
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  类结构</span>
 
<span class="kw">struct</span> _clone_t {
    zctx_t *ctx;                <span class="co">//  上下文</span>
    <span class="dt">void</span> *pipe;                 <span class="co">//  和后台代理间的通信套接字</span>
};
 
<span class="co">//  该线程用于处理真正的clone类</span>
<span class="dt">static</span> <span class="dt">void</span> clone_agent (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe);
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  构造函数</span>
 
clone_t *
clone_new (<span class="dt">void</span>)
{
    clone_t
        *self;
 
    self = (clone_t *) zmalloc (<span class="kw">sizeof</span> (clone_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, clone_agent, NULL);
    <span class="kw">return</span> self;
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  析构函数</span>
 
<span class="dt">void</span>
clone_destroy (clone_t **self_p)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        clone_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  在链接之前指定快照和更新事件的子树</span>
<span class="co">//  发送给后台代理的消息内容为[SUBTREE][subtree]</span>
 
<span class="dt">void</span> clone_subtree (clone_t *self, <span class="dt">char</span> *subtree)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, <span class="st">&quot;SUBTREE&quot;</span>);
    zmsg_addstr (msg, subtree);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  连接至新的服务器端点</span>
<span class="co">//  消息内容：[CONNECT][endpoint][service]</span>
 
<span class="dt">void</span>
clone_connect (clone_t *self, <span class="dt">char</span> *address, <span class="dt">char</span> *service)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, <span class="st">&quot;CONNECT&quot;</span>);
    zmsg_addstr (msg, address);
    zmsg_addstr (msg, service);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  设置新值</span>
<span class="co">//  消息内容：[SET][key][value][ttl]</span>
 
<span class="dt">void</span>
clone_set (clone_t *self, <span class="dt">char</span> *key, <span class="dt">char</span> *value, <span class="dt">int</span> ttl)
{
    <span class="dt">char</span> ttlstr [<span class="dv">10</span>];
    sprintf (ttlstr, <span class="st">&quot;%d&quot;</span>, ttl);
 
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, <span class="st">&quot;SET&quot;</span>);
    zmsg_addstr (msg, key);
    zmsg_addstr (msg, value);
    zmsg_addstr (msg, ttlstr);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  取值</span>
<span class="co">//  消息内容：[GET][key]</span>
<span class="co">//  如果没有clone可用，会返回NULL</span>
 
<span class="dt">char</span> *
clone_get (clone_t *self, <span class="dt">char</span> *key)
{
    assert (self);
    assert (key);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, <span class="st">&quot;GET&quot;</span>);
    zmsg_addstr (msg, key);
    zmsg_send (&amp;msg, self-&gt;pipe);
 
    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    <span class="kw">if</span> (reply) {
        <span class="dt">char</span> *value = zmsg_popstr (reply);
        zmsg_destroy (&amp;reply);
        <span class="kw">return</span> value;
    }
    <span class="kw">return</span> NULL;
}
 
 
<span class="co">//  =====================================================================</span>
<span class="co">//  异步部分，在后台运行</span>
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  单个服务端信息</span>
 
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">char</span> *address;              <span class="co">//  服务端地址</span>
    <span class="dt">int</span> port;                   <span class="co">//  端口</span>
    <span class="dt">void</span> *snapshot;             <span class="co">//  快照套接字</span>
    <span class="dt">void</span> *subscriber;           <span class="co">//  接收更新事件的套接字</span>
    <span class="dt">uint64_t</span> expiry;            <span class="co">//  服务器过期时间</span>
    uint requests;              <span class="co">//  收到的快照请求数</span>
} server_t;
 
<span class="dt">static</span> server_t *
server_new (zctx_t *ctx, <span class="dt">char</span> *address, <span class="dt">int</span> port, <span class="dt">char</span> *subtree)
{
    server_t *self = (server_t *) zmalloc (<span class="kw">sizeof</span> (server_t));
 
    zclock_log (<span class="st">&quot;I: adding server %s:%d...&quot;</span>, address, port);
    self-&gt;address = strdup (address);
    self-&gt;port = port;
 
    self-&gt;snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (self-&gt;snapshot, <span class="st">&quot;%s:%d&quot;</span>, address, port);
    self-&gt;subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, <span class="st">&quot;%s:%d&quot;</span>, address, port + <span class="dv">1</span>);
    zsockopt_set_subscribe (self-&gt;subscriber, subtree);
    <span class="kw">return</span> self;
}
 
<span class="dt">static</span> <span class="dt">void</span>
server_destroy (server_t **self_p)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;address);
        free (self);
        *self_p = NULL;
    }
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  后台代理类</span>
 
<span class="co">//  状态</span>
<span class="ot">#define STATE_INITIAL       0   </span><span class="co">//  连接之前</span>
<span class="ot">#define STATE_SYNCING       1   </span><span class="co">//  正在同步</span>
<span class="ot">#define STATE_ACTIVE        2   </span><span class="co">//  正在更新</span>
 
<span class="kw">typedef</span> <span class="kw">struct</span> {
    zctx_t *ctx;                <span class="co">//  上下文</span>
    <span class="dt">void</span> *pipe;                 <span class="co">//  与主线程通信的套接字</span>
    zhash_t *kvmap;             <span class="co">//  键值表</span>
    <span class="dt">char</span> *subtree;              <span class="co">//  子树</span>
    server_t *server [SERVER_MAX];
    uint nbr_servers;           <span class="co">//  范围：0 - SERVER_MAX</span>
    uint state;                 <span class="co">//  当前状态</span>
    uint cur_server;            <span class="co">//  当前master，0/1</span>
    <span class="dt">int64_t</span> sequence;           <span class="co">//  键值对编号</span>
    <span class="dt">void</span> *publisher;            <span class="co">//  发布更新事件的套接字</span>
} agent_t;
 
<span class="dt">static</span> agent_t *
agent_new (zctx_t *ctx, <span class="dt">void</span> *pipe)
{
    agent_t *self = (agent_t *) zmalloc (<span class="kw">sizeof</span> (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;kvmap = zhash_new ();
    self-&gt;subtree = strdup (<span class="st">&quot;&quot;</span>);
    self-&gt;state = STATE_INITIAL;
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    <span class="kw">return</span> self;
}
 
<span class="dt">static</span> <span class="dt">void</span>
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    <span class="kw">if</span> (*self_p) {
        agent_t *self = *self_p;
        <span class="dt">int</span> server_nbr;
        <span class="kw">for</span> (server_nbr = <span class="dv">0</span>; server_nbr &lt; self-&gt;nbr_servers; server_nbr++)
            server_destroy (&amp;self-&gt;server [server_nbr]);
        zhash_destroy (&amp;self-&gt;kvmap);
        free (self-&gt;subtree);
        free (self);
        *self_p = NULL;
    }
}
 
<span class="co">//  若线程被中断则返回-1</span>
<span class="dt">static</span> <span class="dt">int</span>
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    <span class="dt">char</span> *command = zmsg_popstr (msg);
    <span class="kw">if</span> (command == NULL)
        <span class="kw">return</span> -<span class="dv">1</span>;
 
    <span class="kw">if</span> (streq (command, <span class="st">&quot;SUBTREE&quot;</span>)) {
        free (self-&gt;subtree);
        self-&gt;subtree = zmsg_popstr (msg);
    }
    <span class="kw">else</span>
    <span class="kw">if</span> (streq (command, <span class="st">&quot;CONNECT&quot;</span>)) {
        <span class="dt">char</span> *address = zmsg_popstr (msg);
        <span class="dt">char</span> *service = zmsg_popstr (msg);
        <span class="kw">if</span> (self-&gt;nbr_servers &lt; SERVER_MAX) {
            self-&gt;server [self-&gt;nbr_servers++] = server_new (
                self-&gt;ctx, address, atoi (service), self-&gt;subtree);
            <span class="co">//  广播更新事件</span>
            zsocket_connect (self-&gt;publisher, <span class="st">&quot;%s:%d&quot;</span>,
                address, atoi (service) + <span class="dv">2</span>);
        }
        <span class="kw">else</span>
            zclock_log (<span class="st">&quot;E: too many servers (max. %d)&quot;</span>, SERVER_MAX);
        free (address);
        free (service);
    }
    <span class="kw">else</span>
    <span class="kw">if</span> (streq (command, <span class="st">&quot;SET&quot;</span>)) {
        <span class="dt">char</span> *key = zmsg_popstr (msg);
        <span class="dt">char</span> *value = zmsg_popstr (msg);
        <span class="dt">char</span> *ttl = zmsg_popstr (msg);
        zhash_update (self-&gt;kvmap, key, (byte *) value);
        zhash_freefn (self-&gt;kvmap, key, free);
 
        <span class="co">//  向服务端发送键值对</span>
        kvmsg_t *kvmsg = kvmsg_new (<span class="dv">0</span>);
        kvmsg_set_key  (kvmsg, key);
        kvmsg_set_uuid (kvmsg);
        kvmsg_fmt_body (kvmsg, <span class="st">&quot;%s&quot;</span>, value);
        kvmsg_set_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>, ttl);
        kvmsg_send     (kvmsg, self-&gt;publisher);
        kvmsg_destroy (&amp;kvmsg);
puts (key);
        free (ttl);
        free (key);             <span class="co">//  键值对实际由哈希表对象控制</span>
    }
    <span class="kw">else</span>
    <span class="kw">if</span> (streq (command, <span class="st">&quot;GET&quot;</span>)) {
        <span class="dt">char</span> *key = zmsg_popstr (msg);
        <span class="dt">char</span> *value = zhash_lookup (self-&gt;kvmap, key);
        <span class="kw">if</span> (value)
            zstr_send (self-&gt;pipe, value);
        <span class="kw">else</span>
            zstr_send (self-&gt;pipe, <span class="st">&quot;&quot;</span>);
        free (key);
        free (value);
    }
    free (command);
    zmsg_destroy (&amp;msg);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  异步的后台代理会维护一个服务端池，并处理来自应用程序的请求或应答。</span>
 
<span class="dt">static</span> <span class="dt">void</span>
clone_agent (<span class="dt">void</span> *args, zctx_t *ctx, <span class="dt">void</span> *pipe)
{
    agent_t *self = agent_new (ctx, pipe);
 
    <span class="kw">while</span> (TRUE) {
        zmq_pollitem_t poll_set [] = {
            { pipe, <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> },
            { <span class="dv">0</span>,    <span class="dv">0</span>, ZMQ_POLLIN, <span class="dv">0</span> }
        };
        <span class="dt">int</span> poll_timer = -<span class="dv">1</span>;
        <span class="dt">int</span> poll_size = <span class="dv">2</span>;
        server_t *server = self-&gt;server [self-&gt;cur_server];
        <span class="kw">switch</span> (self-&gt;state) {
            <span class="kw">case</span> STATE_INITIAL:
                <span class="co">//  该状态下，如果有可用服务，会发送快照请求</span>
                <span class="kw">if</span> (self-&gt;nbr_servers &gt; <span class="dv">0</span>) {
                    zclock_log (<span class="st">&quot;I: 正在等待服务器 %s:%d...&quot;</span>,
                        server-&gt;address, server-&gt;port);
                    <span class="kw">if</span> (server-&gt;requests &lt; <span class="dv">2</span>) {
                        zstr_sendm (server-&gt;snapshot, <span class="st">&quot;ICANHAZ?&quot;</span>);
                        zstr_send  (server-&gt;snapshot, self-&gt;subtree);
                        server-&gt;requests++;
                    }
                    server-&gt;expiry = zclock_time () + SERVER_TTL;
                    self-&gt;state = STATE_SYNCING;
                    poll_set [<span class="dv">1</span>].socket = server-&gt;snapshot;
                }
                <span class="kw">else</span>
                    poll_size = <span class="dv">1</span>;
                <span class="kw">break</span>;
            <span class="kw">case</span> STATE_SYNCING:
                <span class="co">//  该状态下我们从服务器端接收快照内容，若失败则尝试其他服务器</span>
                poll_set [<span class="dv">1</span>].socket = server-&gt;snapshot;
                <span class="kw">break</span>;
            <span class="kw">case</span> STATE_ACTIVE:
                <span class="co">//  该状态下我们从服务器获取更新事件，失败则尝试其他服务器</span>
                poll_set [<span class="dv">1</span>].socket = server-&gt;subscriber;
                <span class="kw">break</span>;
        }
        <span class="kw">if</span> (server) {
            poll_timer = (server-&gt;expiry - zclock_time ())
                       * ZMQ_POLL_MSEC;
            <span class="kw">if</span> (poll_timer &lt; <span class="dv">0</span>)
                poll_timer = <span class="dv">0</span>;
        }
        <span class="co">//  ------------------------------------------------------------</span>
        <span class="co">//  poll循环</span>
        <span class="dt">int</span> rc = zmq_poll (poll_set, poll_size, poll_timer);
        <span class="kw">if</span> (rc == -<span class="dv">1</span>)
            <span class="kw">break</span>;              <span class="co">//  上下文已被关闭</span>
 
        <span class="kw">if</span> (poll_set [<span class="dv">0</span>].revents &amp; ZMQ_POLLIN) {
            <span class="kw">if</span> (agent_control_message (self))
                <span class="kw">break</span>;          <span class="co">//  中断</span>
        }
        <span class="kw">else</span>
        <span class="kw">if</span> (poll_set [<span class="dv">1</span>].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (poll_set [<span class="dv">1</span>].socket);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
 
            <span class="co">//  任何服务端的消息将重置它的过期时间</span>
            server-&gt;expiry = zclock_time () + SERVER_TTL;
            <span class="kw">if</span> (self-&gt;state == STATE_SYNCING) {
                <span class="co">//  保存快照内容</span>
                server-&gt;requests = <span class="dv">0</span>;
                <span class="kw">if</span> (streq (kvmsg_key (kvmsg), <span class="st">&quot;KTHXBAI&quot;</span>)) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    self-&gt;state = STATE_ACTIVE;
                    zclock_log (<span class="st">&quot;I: received from %s:%d snapshot=%d&quot;</span>,
                        server-&gt;address, server-&gt;port,
                        (<span class="dt">int</span>) self-&gt;sequence);
                    kvmsg_destroy (&amp;kvmsg);
                }
                <span class="kw">else</span>
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            }
            <span class="kw">else</span>
            <span class="kw">if</span> (self-&gt;state == STATE_ACTIVE) {
                <span class="co">//  丢弃过期的更新事件</span>
                <span class="kw">if</span> (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
                    zclock_log (<span class="st">&quot;I: received from %s:%d update=%d&quot;</span>,
                        server-&gt;address, server-&gt;port,
                        (<span class="dt">int</span>) self-&gt;sequence);
                }
                <span class="kw">else</span>
                    kvmsg_destroy (&amp;kvmsg);
            }
        }
        <span class="kw">else</span> {
            <span class="co">//  服务端已死，尝试其他服务器</span>
            zclock_log (<span class="st">&quot;I: 服务器 %s:%d 无响应&quot;</span>,
                    server-&gt;address, server-&gt;port);
            self-&gt;cur_server = (self-&gt;cur_server + <span class="dv">1</span>) % self-&gt;nbr_servers;
            self-&gt;state = STATE_INITIAL;
        }
    }
    agent_destroy (&amp;self);
}</code></pre></div>
<p>最后是克隆服务器的模型6代码：</p>
<p><strong>clonesrv6: Clone server, Model Six in C</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//</span>
<span class="co">// 克隆模式 - 服务端 - 模型6</span>
<span class="co">//</span>
 
<span class="co">//  直接编译，不建类库</span>
<span class="ot">#include &quot;bstar.c&quot;</span>
<span class="ot">#include &quot;kvmsg.c&quot;</span>
 
<span class="co">//  bstar反应堆API</span>
<span class="dt">static</span> <span class="dt">int</span> s_snapshots  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_collector  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_flush_ttl  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_send_hugz  (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_new_master (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_new_slave  (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args);
<span class="dt">static</span> <span class="dt">int</span> s_subscriber (zloop_t *loop, <span class="dt">void</span> *socket, <span class="dt">void</span> *args);
 
<span class="co">//  服务端属性</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    zctx_t *ctx;                <span class="co">//  上下文</span>
    zhash_t *kvmap;             <span class="co">//  存放键值对</span>
    bstar_t *bstar;             <span class="co">//  bstar反应堆核心</span>
    <span class="dt">int64_t</span> sequence;           <span class="co">//  更新事件编号</span>
    <span class="dt">int</span> port;                   <span class="co">//  主端口</span>
    <span class="dt">int</span> peer;                   <span class="co">//  同伴端口</span>
    <span class="dt">void</span> *publisher;            <span class="co">//  发布更新事件的端口</span>
    <span class="dt">void</span> *collector;            <span class="co">//  接收客户端更新事件的端口</span>
    <span class="dt">void</span> *subscriber;           <span class="co">//  接受同伴更新事件的端口</span>
    zlist_t *pending;           <span class="co">//  延迟的更新事件</span>
    Bool primary;               <span class="co">//  是否为主机</span>
    Bool master;                <span class="co">//  是否为master</span>
    Bool slave;                 <span class="co">//  是否为slave</span>
} clonesrv_t;
 
 
<span class="dt">int</span> main (<span class="dt">int</span> argc, <span class="dt">char</span> *argv [])
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (<span class="kw">sizeof</span> (clonesrv_t));
    <span class="kw">if</span> (argc == <span class="dv">2</span> &amp;&amp; streq (argv [<span class="dv">1</span>], <span class="st">&quot;-p&quot;</span>)) {
        zclock_log (<span class="st">&quot;I: 作为主机master运行，正在等待备机slave连接。&quot;</span>);
        self-&gt;bstar = bstar_new (BSTAR_PRIMARY, <span class="st">&quot;tcp://*:5003&quot;</span>,
                                 <span class="st">&quot;tcp://localhost:5004&quot;</span>);
        bstar_voter (self-&gt;bstar, <span class="st">&quot;tcp://*:5556&quot;</span>, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = <span class="dv">5556</span>;
        self-&gt;peer = <span class="dv">5566</span>;
        self-&gt;primary = TRUE;
    }
    <span class="kw">else</span>
    <span class="kw">if</span> (argc == <span class="dv">2</span> &amp;&amp; streq (argv [<span class="dv">1</span>], <span class="st">&quot;-b&quot;</span>)) {
        zclock_log (<span class="st">&quot;I: 作为备机slave运行，正在等待主机master连接。&quot;</span>);
        self-&gt;bstar = bstar_new (BSTAR_BACKUP, <span class="st">&quot;tcp://*:5004&quot;</span>,
                                 <span class="st">&quot;tcp://localhost:5003&quot;</span>);
        bstar_voter (self-&gt;bstar, <span class="st">&quot;tcp://*:5566&quot;</span>, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = <span class="dv">5566</span>;
        self-&gt;peer = <span class="dv">5556</span>;
        self-&gt;primary = FALSE;
    }
    <span class="kw">else</span> {
        printf (<span class="st">&quot;Usage: clonesrv4 { -p | -b }</span><span class="ch">\n</span><span class="st">&quot;</span>);
        free (self);
        exit (<span class="dv">0</span>);
    }
    <span class="co">//  主机将成为master</span>
    <span class="kw">if</span> (self-&gt;primary)
        self-&gt;kvmap = zhash_new ();
 
    self-&gt;ctx = zctx_new ();
    self-&gt;pending = zlist_new ();
    bstar_set_verbose (self-&gt;bstar, TRUE);
 
    <span class="co">//  设置克隆服务端套接字</span>
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_bind (self-&gt;publisher, <span class="st">&quot;tcp://*:%d&quot;</span>, self-&gt;port + <span class="dv">1</span>);
    zsocket_bind (self-&gt;collector, <span class="st">&quot;tcp://*:%d&quot;</span>, self-&gt;port + <span class="dv">2</span>);
 
    <span class="co">//  作为克隆客户端连接同伴</span>
    self-&gt;subscriber = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, <span class="st">&quot;tcp://localhost:%d&quot;</span>, self-&gt;peer + <span class="dv">1</span>);
 
    <span class="co">//  注册状态事件处理器</span>
    bstar_new_master (self-&gt;bstar, s_new_master, self);
    bstar_new_slave (self-&gt;bstar, s_new_slave, self);
 
    <span class="co">//  注册bstar反应堆其他事件处理器</span>
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;collector, s_collector, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), <span class="dv">1000</span>, <span class="dv">0</span>, s_flush_ttl, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), <span class="dv">1000</span>, <span class="dv">0</span>, s_send_hugz, self);
 
    <span class="co">//  开启bstar反应堆</span>
    bstar_start (self-&gt;bstar);
 
    <span class="co">//  中断，终止。</span>
    <span class="kw">while</span> (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_destroy (&amp;kvmsg);
    }
    zlist_destroy (&amp;self-&gt;pending);
    bstar_destroy (&amp;self-&gt;bstar);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  发送快照内容</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="co">//  请求方信息</span>
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">void</span> *socket;           <span class="co">//  ROUTER套接字</span>
    zframe_t *identity;     <span class="co">//  请求放标识</span>
    <span class="dt">char</span> *subtree;          <span class="co">//  子树</span>
} kvroute_t;
 
<span class="dt">static</span> <span class="dt">int</span>
s_snapshots (zloop_t *loop, <span class="dt">void</span> *snapshot, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    zframe_t *identity = zframe_recv (snapshot);
    <span class="kw">if</span> (identity) {
        <span class="co">//  请求在消息的第二帧中</span>
        <span class="dt">char</span> *request = zstr_recv (snapshot);
        <span class="dt">char</span> *subtree = NULL;
        <span class="kw">if</span> (streq (request, <span class="st">&quot;ICANHAZ?&quot;</span>)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        <span class="kw">else</span>
            printf (<span class="st">&quot;E: 错误的请求，正在退出……</span><span class="ch">\n</span><span class="st">&quot;</span>);
 
        <span class="kw">if</span> (subtree) {
            <span class="co">//  发送状态快照</span>
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);
 
            <span class="co">//  发送终止消息，以及消息编号</span>
            zclock_log (<span class="st">&quot;I: 正在发送快照，版本号：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, <span class="st">&quot;KTHXBAI&quot;</span>);
            kvmsg_set_body (kvmsg, (byte *) subtree, <span class="dv">0</span>);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  每次发送一个快照键值对</span>
<span class="dt">static</span> <span class="dt">int</span>
s_send_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    <span class="kw">if</span> (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == <span class="dv">0</span>) {
        <span class="co">//  先发送接收方的地址</span>
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  从客户端收集更新事件</span>
<span class="co">//  如果我们是master，则将该事件写入kvmap对象；</span>
<span class="co">//  如果我们是slave，则将其写入延迟队列</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg);
 
<span class="dt">static</span> <span class="dt">int</span>
s_collector (zloop_t *loop, <span class="dt">void</span> *collector, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    kvmsg_t *kvmsg = kvmsg_recv (collector);
    kvmsg_dump (kvmsg);
    <span class="kw">if</span> (kvmsg) {
        <span class="kw">if</span> (self-&gt;master) {
            kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
            kvmsg_send (kvmsg, self-&gt;publisher);
            <span class="dt">int</span> ttl = atoi (kvmsg_get_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>));
            <span class="kw">if</span> (ttl)
                kvmsg_set_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>,
                    <span class="st">&quot;%&quot;</span> PRId64, zclock_time () + ttl * <span class="dv">1000</span>);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (<span class="st">&quot;I: 正在发布更新事件：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
        }
        <span class="kw">else</span> {
            <span class="co">//  如果我们已经从master中获得了该事件，则丢弃该消息</span>
            <span class="kw">if</span> (s_was_pending (self, kvmsg))
                kvmsg_destroy (&amp;kvmsg);
            <span class="kw">else</span>
                zlist_append (self-&gt;pending, kvmsg);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  如果消息已在延迟队列中，则删除它并返回TRUE</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg)
{
    kvmsg_t *held = (kvmsg_t *) zlist_first (self-&gt;pending);
    <span class="kw">while</span> (held) {
        <span class="kw">if</span> (memcmp (kvmsg_uuid (kvmsg),
                    kvmsg_uuid (held), <span class="kw">sizeof</span> (uuid_t)) == <span class="dv">0</span>) {
            zlist_remove (self-&gt;pending, held);
            <span class="kw">return</span> TRUE;
        }
        held = (kvmsg_t *) zlist_next (self-&gt;pending);
    }
    <span class="kw">return</span> FALSE;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  删除带有过期时间的瞬间值</span>
 
<span class="dt">static</span> <span class="dt">int</span> s_flush_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args);
 
<span class="dt">static</span> <span class="dt">int</span>
s_flush_ttl (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  如果键值对过期，则进行删除操作，并广播该事件</span>
<span class="dt">static</span> <span class="dt">int</span>
s_flush_single (<span class="dt">char</span> *key, <span class="dt">void</span> *data, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    <span class="dt">int64_t</span> ttl;
    sscanf (kvmsg_get_prop (kvmsg, <span class="st">&quot;ttl&quot;</span>), <span class="st">&quot;%&quot;</span> PRId64, &amp;ttl);
    <span class="kw">if</span> (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;&quot;</span>, <span class="dv">0</span>);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (<span class="st">&quot;I: 正在发布删除事件：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  发送心跳</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_send_hugz (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
    kvmsg_set_key  (kvmsg, <span class="st">&quot;HUGZ&quot;</span>);
    kvmsg_set_body (kvmsg, (byte *) <span class="st">&quot;&quot;</span>, <span class="dv">0</span>);
    kvmsg_send     (kvmsg, self-&gt;publisher);
    kvmsg_destroy (&amp;kvmsg);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  状态改变事件处理函数</span>
<span class="co">//  我们将转变为master</span>
<span class="co">//</span>
<span class="co">//  备机先将延迟列表中的事件更新到自己的快照中，</span>
<span class="co">//  并开始接收客户端发来的快照请求。</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_new_master (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    self-&gt;master = TRUE;
    self-&gt;slave = FALSE;
    zloop_cancel (bstar_zloop (self-&gt;bstar), self-&gt;subscriber);
 
    <span class="co">//  应用延迟列表中的事件</span>
    <span class="kw">while</span> (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (<span class="st">&quot;I: 正在发布延迟列表中的更新事件：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  正在切换为slave</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_new_slave (zloop_t *loop, <span class="dt">void</span> *unused, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
 
    zhash_destroy (&amp;self-&gt;kvmap);
    self-&gt;master = FALSE;
    self-&gt;slave = TRUE;
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;subscriber,
                  s_subscriber, self);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}
 
<span class="co">//  ---------------------------------------------------------------------</span>
<span class="co">//  从同伴主机（master）接收更新事件；</span>
<span class="co">//  接收该类更新事件时，我们一定是slave。</span>
 
<span class="dt">static</span> <span class="dt">int</span>
s_subscriber (zloop_t *loop, <span class="dt">void</span> *subscriber, <span class="dt">void</span> *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    <span class="co">//  获取快照，如果需要的话。</span>
    <span class="kw">if</span> (self-&gt;kvmap == NULL) {
        self-&gt;kvmap = zhash_new ();
        <span class="dt">void</span> *snapshot = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
        zsocket_connect (snapshot, <span class="st">&quot;tcp://localhost:%d&quot;</span>, self-&gt;peer);
        zclock_log (<span class="st">&quot;I: 正在请求快照：tcp://localhost:%d&quot;</span>,
                    self-&gt;peer);
        zstr_send (snapshot, <span class="st">&quot;ICANHAZ?&quot;</span>);
        <span class="kw">while</span> (TRUE) {
            kvmsg_t *kvmsg = kvmsg_recv (snapshot);
            <span class="kw">if</span> (!kvmsg)
                <span class="kw">break</span>;          <span class="co">//  中断</span>
            <span class="kw">if</span> (streq (kvmsg_key (kvmsg), <span class="st">&quot;KTHXBAI&quot;</span>)) {
                self-&gt;sequence = kvmsg_sequence (kvmsg);
                kvmsg_destroy (&amp;kvmsg);
                <span class="kw">break</span>;          <span class="co">//  完成</span>
            }
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        }
        zclock_log (<span class="st">&quot;I: 收到快照，版本号：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
        zsocket_destroy (self-&gt;ctx, snapshot);
    }
    <span class="co">//  查找并删除</span>
    kvmsg_t *kvmsg = kvmsg_recv (subscriber);
    <span class="kw">if</span> (!kvmsg)
        <span class="kw">return</span> <span class="dv">0</span>;
 
    <span class="kw">if</span> (strneq (kvmsg_key (kvmsg), <span class="st">&quot;HUGZ&quot;</span>)) {
        <span class="kw">if</span> (!s_was_pending (self, kvmsg)) {
            <span class="co">//  如果master的更新事件比客户端的事件早到，则将master的事件存入延迟列表，</span>
            <span class="co">//  当收到客户端更新事件时会将其从列表中清除。</span>
            zlist_append (self-&gt;pending, kvmsg_dup (kvmsg));
        }
        <span class="co">//  如果更新事件比kvmap版本高，则应用它</span>
        <span class="kw">if</span> (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
            self-&gt;sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (<span class="st">&quot;I: 收到更新事件：%d&quot;</span>, (<span class="dt">int</span>) self-&gt;sequence);
        }
        <span class="kw">else</span>
            kvmsg_destroy (&amp;kvmsg);
    }
    <span class="kw">else</span>
        kvmsg_destroy (&amp;kvmsg);
 
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>这段程序只有几百行，但还是花了一些时间来进行调通的。这个模型中包含了故障恢复，瞬间值，子树等等。虽然我们前期设计得很完备，但要在多个套接字之间进行调试还是很困难的。以下是我的工作方式：</p>
<ul>
<li><p>由于使用了反应堆（bstar，建立在zloop之上），我们节省了大量的代码，让程序变得简洁明了。整个服务以一个线程运行，因此不会出现跨线程的问题。只需将结构指针（self）传递给所有的处理器即可。此外，使用发应堆后可以让代码更为模块化，易于重用。</p></li>
<li><p>我们逐个模块进行调试，只有某个模块能够正常运行时才会进入下一步。由于使用了四五个套接字，因此调试的工作量是很大的。我直接将调试信息输出到了屏幕上，因为实在没有必要专门开一个调试器来工作。</p></li>
<li><p>因为一直在使用valgrind工具进行测试，因此我能确定程序没有内存泄漏的问题。在C语言中，内存泄漏是我们非常关心的问题，因为没有什么垃圾回收机制可以帮你完成。正确地使用像kvmsg、czmq之类的抽象层可以很好地避免内存泄漏。</p></li>
</ul>
<p>这段程序肯定还会存在一些BUG，部分读者可能会帮助我调试和修复，我在此表示感谢。</p>
<p>测试模型6时，先开启主机和备机，再打开一组客户端，顺序随意。随机地中止某个服务进程，如果程序设计得是正确的，那客户端获得的数据应该都是一致的。</p>
<h4 id="克隆模式协议">克隆模式协议</h4>
<p>花费了那么多精力来开发一套可靠的发布-订阅模式机制，我们当然希望将来能够方便地在其基础之上进行扩展。较好的方法是将其编写为一个协议，这样就能让各种语言来实现它了。</p>
<p>我们将其称为“集群化哈希表协议”，这是一个能够跨集群地进行键值哈希表管理，提供了多客户端的通信机制；客户端可以只操作一个子树的数据，包括更新和定义瞬间值。</p>
<ul>
<li>http://rfc.zeromq.org/spec:12</li>
</ul>
</body>
</html>
